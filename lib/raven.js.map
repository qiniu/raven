{"version":3,"sources":["webpack:///raven.js","webpack:///webpack/bootstrap 6faffaa71edddc62aa6e","webpack:///./src/utils.ts","webpack:///./src/detection.ts","webpack:///./src/source.ts","webpack:///./src/store.ts","webpack:///(webpack)/buildin/global.js","webpack:///./src/transfer.ts","webpack:///./node_modules/tracekit/tracekit.js","webpack:///./src/logger.ts","webpack:///./src/index.ts","webpack:///./src/raven.ts","webpack:///./src/messages-store.ts","webpack:///./src/sources/xhr.ts","webpack:///./src/sources/console.ts","webpack:///./src/sources/history.ts","webpack:///./src/sources/ui-event.ts","webpack:///./src/sources/exception.ts"],"names":["this","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","fill","obj","replacement","track","orig","push","serializeDOMElement","dom","dataSet","slice","attributes","filter","attr","dataAttrRegex","test","map","substr","replace","$0","$1","toUpperCase","value","data","_i","dataSet_1","length","_a","key","tag","tagName","class","className","split","Boolean","id","htmlTreeAsString","elem","nextStr","out","sepLength","height","len","MAX_TRAVERSE_HEIGHT","htmlElementAsString","MAX_OUTPUT_LEN","parentNode","reverse","join","classes","toLowerCase","attrWhitelist","getAttribute","hasKey","objectPrototype","merge","target","source","isString","raw","isNull","isUndefined","isObject","isError","Error","isNil","isFunction","apply","isArray","Array","pop","clone","detection_1","hasJSON","JSON","parse","stringify","global","utils_1","_window","window","self","_document","_navigator","hasDocument","hasNavigator","GEN_DEFAULT_SOURCE_MESSAGE","type","category","payload","timestamp","Date","now","Source","processorFunc","receivers","processor","action","bind","message","mergedMessage","forEach","receiver","onAction","callback","dispose","default","__extends","extendStatics","setPrototypeOf","__proto__","b","__","constructor","create","Storage","setItem","getItem","removeItem","clear","realStorage","Store","_storage","keys","bindRealStorage","storage","set","indexOf","has","remove","index","splice","toJS","CollectionStore","_super","_this","arguments","collect","item","current","_update","shift","unshift","collection","g","Function","eval","e","duplex","store_1","Transfer","transferFunc","queue","running","configStore","transfer","config","keyOrObject","value_1","send","sent","Promise","resolve","reject","extendMessage","then","catch","run","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","_has","_isUndefined","what","TraceKit","_oldTraceKit","_slice","UNKNOWN_FUNCTION","ERROR_TYPES_RE","noConflict","wrap","func","wrapped","report","subscribe","handler","installGlobalHandler","handlers","unsubscribe","onerror","_oldOnerrorHandler","_onErrorHandlerInstalled","notifyHandlers","stack","isWindowError","error","exception","collectWindowErrors","inner","traceKitWindowOnError","url","lineNo","columnNo","errorObj","lastExceptionStack","computeStackTrace","augmentStackTraceWithInitialElement","processLastException","location","line","column","msg","toString","groups","match","guessFunctionName","context","gatherContext","mode","_lastExceptionStack","_lastException","lastException","ex","setTimeout","incomplete","loadSource","remoteFetching","request","XMLHttpRequest","ActiveXObject","open","responseText","getSource","sourceCache","domain","document","exec","reFunctionArgNames","reGuessFunction","linesBefore","Math","floor","linesOfContext","linesAfter","start","max","end","min","escapeRegExp","text","escapeCodeAsRegExpForMatchingInsideHTML","body","findSourceInUrls","re","urls","j","substring","lastIndexOf","findSourceInLine","fragment","RegExp","findSourceByFunctionBody","parts","result","href","scripts","getElementsByTagName","code","codeRE","eventRE","script","src","args","event","computeStackTraceFromStackProp","isEval","submatch","element","chrome","gecko","winjs","geckoEval","chromeEval","lines","reference","isNative","columnNumber","computeStackTraceFromStacktraceProp","stacktrace","opera10Regex","opera11Regex","exc","computeStackTraceFromOperaMultiLineMessage","lineRE1","lineRE2","lineRE3","inlineScriptBlocks","relativeLine","pos","innerText","midline","stackInfo","initial","partial","computeStackTraceByWalkingCallerChain","depth","functionName","funcs","recursion","curr","caller","input","description","sourceURL","fileName","lineNumber","debug","computeStackTraceOfCaller","ofCaller","extendToAsynchronousCallbacks","_helper","fnName","originalFn","originalCallback","levels","originalLevels","level","console","levelColors","qiniu","normal","log","info","warn","logger","concat","raven_1","composeCallback","original","messages_store_1","transfer_1","source_1","xhr_1","console_1","history_1","ui_event_1","exception_1","logger_1","DEFAULT_RAVEN_OPTION","environment","autoInstall","instrument","tryCatch","autoBreadcrumbs","xhr","history","Raven","option","callbacks","contextStore","messages","MessagesStore","transfers","sources","__wrappedBuiltins","_ignoreOnError","release","setRelease","setEnvironment","addTransfer","_b","_c","addSource","install","col","err","captureException","_setupBreadcrumb","uninstall","_restoreBuiltIns","add","options","trimHeadFrames","ex1","setUserContext","user","setTagsContext","tags","setExtraContext","extra","clearContext","getContext","env","getCallback","setCallback","setBreadcrumbCallback","setExceptionCallback","_before","deep","_ignoreNextOnError","__raven__","__raven_wrapper__","prop","funcName","argsOrOptions","name_1","raven","raven_option","breadcrumbCategories","isBreadcrumb","parent","counter","store","genXHRMessage","method","status_code","duration","wrapProp","xhrproto","originFunc","__raven_xhr","onreadystatechangeHandler","readyState","timeChecker","clearTimeout","status","startAt","props","props_1","onreadystatechange","fetch","origFetch","fetchInput","fetchData","resp","wrapMethod","originalConsoleLevel","originalConsole","consoleMethodCallback","levels_1","_location","_lastHref","app","runtime","pushState","message_1","to","pageView","pageSize","width","offsetWidth","offsetHeight","screenSize","screen","userAgent","oldOnPopState","onpopstate","currentHref","from","origPushState","domEventHandler","evtName","evt","_keypressTimeout","_lastCapturedEvent","path","x","pageX","y","pageY","keypressHandler","isContentEditable","timeout","debounceDuration","addEventListener","attachEvent","errorMsg"],"mappings":"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","file":"raven.js","sourcesContent":["this[\"raven\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar detection_1 = __webpack_require__(1);\r\n/**\r\n * Polyfill a method\r\n * @param obj object e.g. `document`\r\n * @param name method name present on object e.g. `addEventListener`\r\n * @param replacement replacement function\r\n * @param track {optional} record instrumentation to an array\r\n */\r\nfunction fill(obj, name, replacement, track) {\r\n    var orig = obj[name];\r\n    obj[name] = replacement(orig);\r\n    if (track) {\r\n        track.push([obj, name, orig]);\r\n    }\r\n}\r\nexports.fill = fill;\r\nvar dataAttrRegex = /^data-/;\r\nfunction serializeDOMElement(dom) {\r\n    var dataSet = [].slice.call(dom.attributes)\r\n        .filter(function (attr) { return dataAttrRegex.test(attr.name); })\r\n        .map(function (attr) { return [\r\n        attr.name.substr(5).replace(/-(.)/g, function ($0, $1) { return $1.toUpperCase(); }),\r\n        attr.value\r\n    ]; });\r\n    var data = {};\r\n    for (var _i = 0, dataSet_1 = dataSet; _i < dataSet_1.length; _i++) {\r\n        var _a = dataSet_1[_i], key = _a[0], value = _a[1];\r\n        data[key] = value;\r\n    }\r\n    var serialization = {\r\n        tag: dom.tagName,\r\n        class: dom.className !== '' ? dom.className.split(' ').filter(Boolean) : null,\r\n        id: dom.id || null,\r\n        data: data\r\n    };\r\n    return serialization;\r\n}\r\nexports.serializeDOMElement = serializeDOMElement;\r\nvar MAX_TRAVERSE_HEIGHT = 5;\r\nvar MAX_OUTPUT_LEN = 80;\r\n/**\r\n * Given a child DOM element, returns a query-selector statement describing that\r\n * and its ancestors\r\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\r\n * @param elem\r\n * @returns {string}\r\n */\r\nfunction htmlTreeAsString(elem) {\r\n    /* eslint no-extra-parens:0*/\r\n    var out = [];\r\n    var separator = ' > ';\r\n    var sepLength = separator.length;\r\n    var height = 0;\r\n    var len = 0;\r\n    var nextStr;\r\n    while (elem && height++ < MAX_TRAVERSE_HEIGHT) {\r\n        nextStr = htmlElementAsString(elem);\r\n        // bail out if\r\n        // - nextStr is the 'html' element\r\n        // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\r\n        //   (ignore this limit if we are on the first iteration)\r\n        if (nextStr === 'html' || height > 1 && len + (out.length * sepLength) + nextStr.length >= MAX_OUTPUT_LEN) {\r\n            break;\r\n        }\r\n        out.push(nextStr);\r\n        len += nextStr.length;\r\n        elem = elem.parentNode;\r\n    }\r\n    return out.reverse().join(separator);\r\n}\r\nexports.htmlTreeAsString = htmlTreeAsString;\r\n/**\r\n* Returns a simple, query-selector representation of a DOM element\r\n* e.g. [HTMLElement] => input#foo.btn[name=baz]\r\n* @param HTMLElement\r\n* @returns {string}\r\n*/\r\nfunction htmlElementAsString(elem) {\r\n    var out = [];\r\n    var className;\r\n    var classes;\r\n    var key;\r\n    var attr;\r\n    var i;\r\n    if (!elem || !elem.tagName) {\r\n        return '';\r\n    }\r\n    out.push(elem.tagName.toLowerCase());\r\n    if (elem.id) {\r\n        out.push('#' + elem.id);\r\n    }\r\n    className = elem.className;\r\n    if (className && typeof className === 'string') {\r\n        classes = className.split(/\\s+/);\r\n        for (i = 0; i < classes.length; i++) {\r\n            out.push('.' + classes[i]);\r\n        }\r\n    }\r\n    var attrWhitelist = ['type', 'name', 'title', 'alt'];\r\n    for (i = 0; i < attrWhitelist.length; i++) {\r\n        key = attrWhitelist[i];\r\n        attr = elem.getAttribute(key);\r\n        if (attr) {\r\n            out.push('[' + key + '=\"' + attr + '\"]');\r\n        }\r\n    }\r\n    return out.join('');\r\n}\r\nexports.htmlElementAsString = htmlElementAsString;\r\nvar objectPrototype = Object.prototype;\r\n/**\r\n * hasKey, a better form of hasOwnProperty\r\n * Example: hasKey(MainHostObject, property) === true/false\r\n *\r\n * @param {Object} host object to check property\r\n * @param {string} key to check\r\n */\r\nfunction hasKey(object, key) {\r\n    return objectPrototype.hasOwnProperty.call(object, key);\r\n}\r\nexports.hasKey = hasKey;\r\nfunction merge(target, source) {\r\n    var obj = {};\r\n    for (var key in target) {\r\n        obj[key] = target[key];\r\n    }\r\n    for (var key in source) {\r\n        obj[key] = source[key];\r\n    }\r\n    return obj;\r\n}\r\nexports.merge = merge;\r\n// Simple type check utils\r\nfunction isString(raw) {\r\n    return typeof raw === 'string';\r\n}\r\nexports.isString = isString;\r\nfunction isNull(raw) {\r\n    return raw === null;\r\n}\r\nexports.isNull = isNull;\r\nfunction isUndefined(raw) {\r\n    return raw === void 0;\r\n}\r\nexports.isUndefined = isUndefined;\r\nfunction isObject(raw) {\r\n    return typeof raw === 'object';\r\n}\r\nexports.isObject = isObject;\r\nfunction isError(raw) {\r\n    return raw instanceof Error;\r\n}\r\nexports.isError = isError;\r\nfunction isNil(raw) {\r\n    return isNull(raw) || isUndefined(raw);\r\n}\r\nexports.isNil = isNil;\r\nfunction isFunction(raw) {\r\n    return typeof raw === 'function' &&\r\n        raw.call && raw.apply;\r\n}\r\nexports.isFunction = isFunction;\r\nfunction isArray(raw) {\r\n    return raw instanceof Array && raw.push && raw.pop && raw.length;\r\n}\r\nexports.isArray = isArray;\r\nfunction clone(raw) {\r\n    if (detection_1.hasJSON) {\r\n        return JSON.parse(JSON.stringify(raw));\r\n    }\r\n    else {\r\n        return raw;\r\n    }\r\n}\r\nexports.clone = clone;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(0);\r\nexports._window = !utils_1.isUndefined(window) ? window\r\n    : !utils_1.isUndefined(global) ? global\r\n        : !utils_1.isUndefined(self) ? self\r\n            : {};\r\nexports._document = exports._window['document'];\r\nexports._navigator = exports._window['navigator'];\r\nexports.hasJSON = !!(utils_1.isObject(JSON) && !utils_1.isNil(JSON.stringify));\r\nexports.hasDocument = !utils_1.isUndefined(exports._document);\r\nexports.hasNavigator = !utils_1.isUndefined(exports._navigator);\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(0);\r\nvar GEN_DEFAULT_SOURCE_MESSAGE = function () { return ({\r\n    type: 'message',\r\n    category: 'message',\r\n    payload: {},\r\n    timestamp: Date.now()\r\n}); };\r\nvar Source = (function () {\r\n    /**\r\n     * Class Source\r\n     * @param {string} name Name of the source to identify\r\n     * @param {function} processorFunc The processing function of the source\r\n     *\r\n     * @example\r\n     * new Source((action) => {\r\n     *   whenSomethingHappen((value) => {\r\n     *     action({\r\n     *       category: 'something',\r\n     *       payload: value\r\n     *     })\r\n     *   })\r\n     * })\r\n     */\r\n    function Source(name, processorFunc) {\r\n        this.receivers = [];\r\n        this.name = name;\r\n        this.processor = processorFunc;\r\n        processorFunc(this.action.bind(this));\r\n    }\r\n    /**\r\n     * Fire the message to raven\r\n     * @param {ISourceMessage} message\r\n     */\r\n    Source.prototype.action = function (message) {\r\n        var mergedMessage = utils_1.merge(GEN_DEFAULT_SOURCE_MESSAGE(), message);\r\n        this.receivers.forEach(function (receiver) { return receiver(mergedMessage); });\r\n    };\r\n    /**\r\n     * bind the message event (only call by raven internally)\r\n     * @param callback\r\n     */\r\n    Source.prototype.onAction = function (callback) {\r\n        this.receivers.push(callback);\r\n    };\r\n    /**\r\n     * Dispose the source (only call by raven internally)\r\n     */\r\n    Source.prototype.dispose = function () {\r\n        this.receivers.forEach(function (receiver) { return receiver = null; });\r\n        this.receivers = [];\r\n    };\r\n    return Source;\r\n}());\r\nexports.default = Source;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar stringify = JSON.stringify;\r\nvar Storage = (function () {\r\n    function Storage() {\r\n        this.data = {};\r\n    }\r\n    Storage.prototype.setItem = function (key, value) {\r\n        this.data[key] = value;\r\n    };\r\n    Storage.prototype.getItem = function (key) {\r\n        var value = this.data[key];\r\n        return value;\r\n    };\r\n    Storage.prototype.removeItem = function (key) {\r\n        delete this.data[key];\r\n    };\r\n    Storage.prototype.clear = function () {\r\n        this.data = {};\r\n    };\r\n    return Storage;\r\n}());\r\nexports.Storage = Storage;\r\nvar realStorage = null;\r\nvar Store = (function () {\r\n    function Store(name) {\r\n        this.type = Store;\r\n        this._storage = new Storage();\r\n        this.keys = [];\r\n        this.name = name;\r\n    }\r\n    Store.bindRealStorage = function (storage) {\r\n        realStorage = storage;\r\n    };\r\n    Object.defineProperty(Store.prototype, \"storage\", {\r\n        get: function () {\r\n            if (realStorage) {\r\n                return realStorage;\r\n            }\r\n            else {\r\n                return this._storage;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Store.prototype.set = function (key, value) {\r\n        this.storage.setItem(this.name + \":\" + key, stringify(value));\r\n        if (this.keys.indexOf(key) === -1) {\r\n            this.keys.push(key);\r\n        }\r\n        return value;\r\n    };\r\n    Store.prototype.get = function (key) {\r\n        var value = this.storage.getItem(this.name + \":\" + key);\r\n        if (value) {\r\n            return JSON.parse(value);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    Store.prototype.has = function (key) {\r\n        return this.keys.indexOf(key) >= 0;\r\n    };\r\n    Store.prototype.remove = function (key) {\r\n        this.storage.removeItem(this.name + \":\" + key);\r\n        var index = this.keys.indexOf(key);\r\n        if (index >= 0) {\r\n            this.keys.splice(index, 1);\r\n        }\r\n    };\r\n    Store.prototype.clear = function () {\r\n        this.storage.clear();\r\n        this.keys = [];\r\n    };\r\n    Store.prototype.merge = function (source) {\r\n        for (var key in source) {\r\n            if (source.hasOwnProperty(key)) {\r\n                var value = source[key];\r\n                this.set(key, value);\r\n            }\r\n        }\r\n    };\r\n    Store.prototype.toJS = function () {\r\n        var object = {};\r\n        for (var _i = 0, _a = this.keys; _i < _a.length; _i++) {\r\n            var key = _a[_i];\r\n            object[key] = this.get(key);\r\n        }\r\n        return object;\r\n    };\r\n    return Store;\r\n}());\r\nexports.Store = Store;\r\nvar CollectionStore = (function (_super) {\r\n    __extends(CollectionStore, _super);\r\n    function CollectionStore() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.type = CollectionStore;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(CollectionStore.prototype, \"length\", {\r\n        get: function () {\r\n            return this.collect().length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    CollectionStore.prototype.collect = function () {\r\n        return this.get('collection') || [];\r\n    };\r\n    CollectionStore.prototype.push = function (item) {\r\n        var current = this.collect();\r\n        current.push(item);\r\n        this._update(current);\r\n        return current.length;\r\n    };\r\n    CollectionStore.prototype.pop = function () {\r\n        var current = this.collect();\r\n        var item = current.pop();\r\n        this._update(current);\r\n        return item;\r\n    };\r\n    CollectionStore.prototype.shift = function () {\r\n        var current = this.collect();\r\n        var item = current.shift();\r\n        this._update(current);\r\n        return item;\r\n    };\r\n    CollectionStore.prototype.unshift = function (item) {\r\n        var current = this.collect();\r\n        current.unshift(item);\r\n        this._update(current);\r\n        return current.length;\r\n    };\r\n    CollectionStore.prototype._update = function (collection) {\r\n        this.set('collection', collection);\r\n        this.set('length', collection.length);\r\n    };\r\n    return CollectionStore;\r\n}(Store));\r\nexports.CollectionStore = CollectionStore;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar store_1 = __webpack_require__(3);\r\nvar Transfer = (function () {\r\n    function Transfer(name, transferFunc) {\r\n        if (transferFunc === void 0) { transferFunc = duplex; }\r\n        this.queue = [];\r\n        this.running = false;\r\n        this.name = name;\r\n        this.configStore = new store_1.Store(\"transfer:\" + name);\r\n        this.transfer = transferFunc;\r\n    }\r\n    Transfer.prototype.config = function (keyOrObject, value) {\r\n        if (typeof keyOrObject === 'string') {\r\n            var key = keyOrObject;\r\n            this.configStore.set(key, value);\r\n        }\r\n        else {\r\n            for (var key in keyOrObject) {\r\n                if (keyOrObject.hasOwnProperty(key)) {\r\n                    var value_1 = keyOrObject[key];\r\n                    this.config(key, value_1);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Transfer.prototype.send = function (message) {\r\n        var _this = this;\r\n        var data = message.data, sent = message.sent;\r\n        this.queue.push(function () { return new Promise(function (resolve, reject) {\r\n            _this.transfer.call(_this, _this.extendMessage(data))\r\n                .then(function () {\r\n                message.sent = true;\r\n            })\r\n                .then(resolve)\r\n                .catch(reject);\r\n        }); });\r\n        if (!this.running) {\r\n            this.run();\r\n        }\r\n    };\r\n    Transfer.prototype.extendMessage = function (message) {\r\n        if (this.configStore.has('user')) {\r\n            message['user'] = this.configStore.get('user');\r\n        }\r\n        if (this.configStore.has('tags')) {\r\n            message['tags'] = this.configStore.get('tags');\r\n        }\r\n        if (this.configStore.has('extra')) {\r\n            message['extra'] = this.configStore.get('extra');\r\n        }\r\n        if (this.configStore.has('release')) {\r\n            message['release'] = this.configStore.get('release');\r\n        }\r\n        if (this.configStore.has('environment')) {\r\n            message['environment'] = this.configStore.get('environment');\r\n        }\r\n        return message;\r\n    };\r\n    Transfer.prototype.run = function () {\r\n        var _this = this;\r\n        var current = this.queue.splice(0, 1)[0]; // .shift()\r\n        if (current) {\r\n            this.running = true;\r\n            current()\r\n                .then(function () { return _this.run(); });\r\n        }\r\n        else {\r\n            this.running = false;\r\n        }\r\n    };\r\n    return Transfer;\r\n}());\r\nexports.default = Transfer;\r\nfunction duplex(value) { return value; }\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * https://github.com/csnover/TraceKit\n * @license MIT\n * @namespace TraceKit\n */\n(function(window, undefined) {\nif (!window) {\n    return;\n}\n\nvar TraceKit = {};\nvar _oldTraceKit = window.TraceKit;\n\n// global reference to slice\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n\n/**\n * A better form of hasOwnProperty<br/>\n * Example: `_has(MainHostObject, property) === true/false`\n *\n * @param {Object} object to check property\n * @param {string} key to check\n * @return {Boolean} true if the object has the key and it is not inherited\n */\nfunction _has(object, key) {\n    return Object.prototype.hasOwnProperty.call(object, key);\n}\n\n/**\n * Returns true if the parameter is undefined<br/>\n * Example: `_isUndefined(val) === true/false`\n *\n * @param {*} what Value to check\n * @return {Boolean} true if undefined and false otherwise\n */\nfunction _isUndefined(what) {\n    return typeof what === 'undefined';\n}\n\n/**\n * Export TraceKit out to another variable<br/>\n * Example: `var TK = TraceKit.noConflict()`\n * @return {Object} The TraceKit object\n * @memberof TraceKit\n */\nTraceKit.noConflict = function noConflict() {\n    window.TraceKit = _oldTraceKit;\n    return TraceKit;\n};\n\n/**\n * Wrap any function in a TraceKit reporter<br/>\n * Example: `func = TraceKit.wrap(func);`\n *\n * @param {Function} func Function to be wrapped\n * @return {Function} The wrapped func\n * @memberof TraceKit\n */\nTraceKit.wrap = function traceKitWrapper(func) {\n    function wrapped() {\n        try {\n            return func.apply(this, arguments);\n        } catch (e) {\n            TraceKit.report(e);\n            throw e;\n        }\n    }\n    return wrapped;\n};\n\n/**\n * Cross-browser processing of unhandled exceptions\n *\n * Syntax:\n * ```js\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n * ```\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *     on top frame; column number is not guaranteed\n *   - Opera: full stack trace with line and column numbers\n *   - Chrome: full stack trace with line and column numbers\n *   - Safari: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *   - IE: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a TraceKit.StackTrace object as described in the\n * TraceKit.computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\nTraceKit.report = (function reportModuleWrapper() {\n    var handlers = [],\n        lastException = null,\n        lastExceptionStack = null;\n\n    /**\n     * Add a crash handler.\n     * @param {Function} handler\n     * @memberof TraceKit.report\n     */\n    function subscribe(handler) {\n        installGlobalHandler();\n        handlers.push(handler);\n    }\n\n    /**\n     * Remove a crash handler.\n     * @param {Function} handler\n     * @memberof TraceKit.report\n     */\n    function unsubscribe(handler) {\n        for (var i = handlers.length - 1; i >= 0; --i) {\n            if (handlers[i] === handler) {\n                handlers.splice(i, 1);\n            }\n        }\n\n        if (handlers.length === 0) {\n            window.onerror = _oldOnerrorHandler;\n            _onErrorHandlerInstalled = false;\n        }\n    }\n\n    /**\n     * Dispatch stack information to all handlers.\n     * @param {TraceKit.StackTrace} stack\n     * @param {boolean} isWindowError Is this a top-level window error?\n     * @param {Error=} error The error that's being handled (if available, null otherwise)\n     * @memberof TraceKit.report\n     * @throws An exception if an error occurs while calling an handler.\n     */\n    function notifyHandlers(stack, isWindowError, error) {\n        var exception = null;\n        if (isWindowError && !TraceKit.collectWindowErrors) {\n          return;\n        }\n        for (var i in handlers) {\n            if (_has(handlers, i)) {\n                try {\n                    handlers[i](stack, isWindowError, error);\n                } catch (inner) {\n                    exception = inner;\n                }\n            }\n        }\n\n        if (exception) {\n            throw exception;\n        }\n    }\n\n    var _oldOnerrorHandler, _onErrorHandlerInstalled;\n\n    /**\n     * Ensures all global unhandled exceptions are recorded.\n     * Supported by Gecko and IE.\n     * @param {string} message Error message.\n     * @param {string} url URL of script that generated the exception.\n     * @param {(number|string)} lineNo The line number at which the error occurred.\n     * @param {(number|string)=} columnNo The column number at which the error occurred.\n     * @param {Error=} errorObj The actual Error object.\n     * @memberof TraceKit.report\n     */\n    function traceKitWindowOnError(message, url, lineNo, columnNo, errorObj) {\n        var stack = null;\n\n        if (lastExceptionStack) {\n            TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n    \t    processLastException();\n        } else if (errorObj) {\n            stack = TraceKit.computeStackTrace(errorObj);\n            notifyHandlers(stack, true, errorObj);\n        } else {\n            var location = {\n              'url': url,\n              'line': lineNo,\n              'column': columnNo\n            };\n\n            var name;\n            var msg = message; // must be new var or will modify original `arguments`\n            if ({}.toString.call(message) === '[object String]') {\n                var groups = message.match(ERROR_TYPES_RE);\n                if (groups) {\n                    name = groups[1];\n                    msg = groups[2];\n                }\n            }\n\n            location.func = TraceKit.computeStackTrace.guessFunctionName(location.url, location.line);\n            location.context = TraceKit.computeStackTrace.gatherContext(location.url, location.line);\n            stack = {\n                'name': name,\n                'message': msg,\n                'mode': 'onerror',\n                'stack': [location]\n            };\n\n            notifyHandlers(stack, true, null);\n        }\n\n        if (_oldOnerrorHandler) {\n            return _oldOnerrorHandler.apply(this, arguments);\n        }\n\n        return false;\n    }\n\n    /**\n     * Install a global onerror handler\n     * @memberof TraceKit.report\n     */\n    function installGlobalHandler() {\n        if (_onErrorHandlerInstalled === true) {\n            return;\n        }\n\n        _oldOnerrorHandler = window.onerror;\n        window.onerror = traceKitWindowOnError;\n        _onErrorHandlerInstalled = true;\n    }\n\n    /**\n     * Process the most recent exception\n     * @memberof TraceKit.report\n     */\n    function processLastException() {\n        var _lastExceptionStack = lastExceptionStack,\n            _lastException = lastException;\n        lastExceptionStack = null;\n        lastException = null;\n        notifyHandlers(_lastExceptionStack, false, _lastException);\n    }\n\n    /**\n     * Reports an unhandled Error to TraceKit.\n     * @param {Error} ex\n     * @memberof TraceKit.report\n     * @throws An exception if an incomplete stack trace is detected (old IE browsers).\n     */\n    function report(ex) {\n        if (lastExceptionStack) {\n            if (lastException === ex) {\n                return; // already caught by an inner catch block, ignore\n            } else {\n              processLastException();\n            }\n        }\n\n        var stack = TraceKit.computeStackTrace(ex);\n        lastExceptionStack = stack;\n        lastException = ex;\n\n        // If the stack trace is incomplete, wait for 2 seconds for\n        // slow slow IE to see if onerror occurs or not before reporting\n        // this exception; otherwise, we will end up with an incomplete\n        // stack trace\n        setTimeout(function () {\n            if (lastException === ex) {\n                processLastException();\n            }\n        }, (stack.incomplete ? 2000 : 0));\n\n        throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n    }\n\n    report.subscribe = subscribe;\n    report.unsubscribe = unsubscribe;\n    return report;\n}());\n\n/**\n * An object representing a single stack frame.\n * @typedef {Object} StackFrame\n * @property {string} url The JavaScript or HTML file URL.\n * @property {string} func The function name, or empty for anonymous functions (if guessing did not work).\n * @property {string[]?} args The arguments passed to the function, if known.\n * @property {number=} line The line number, if known.\n * @property {number=} column The column number, if known.\n * @property {string[]} context An array of source code lines; the middle element corresponds to the correct line#.\n * @memberof TraceKit\n */\n\n/**\n * An object representing a JavaScript stack trace.\n * @typedef {Object} StackTrace\n * @property {string} name The name of the thrown exception.\n * @property {string} message The exception error message.\n * @property {TraceKit.StackFrame[]} stack An array of stack frames.\n * @property {string} mode 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace.\n * @memberof TraceKit\n */\n\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   ```js\n *   s = TraceKit.computeStackTrace.ofCaller([depth])\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n *   ```\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n * Tracing example:\n *  ```js\n *     function trace(message) {\n *         var stackInfo = TraceKit.computeStackTrace.ofCaller();\n *         var data = message + \"\\n\";\n *         for(var i in stackInfo.stack) {\n *             var item = stackInfo.stack[i];\n *             data += (item.func || '[anonymous]') + \"() in \" + item.url + \":\" + (item.line || '0') + \"\\n\";\n *         }\n *         if (window.console)\n *             console.info(data);\n *         else\n *             alert(data);\n *     }\n * ```\n * @memberof TraceKit\n * @namespace\n */\nTraceKit.computeStackTrace = (function computeStackTraceWrapper() {\n    var debug = false,\n        sourceCache = {};\n\n    /**\n     * Attempts to retrieve source code via XMLHttpRequest, which is used\n     * to look up anonymous function names.\n     * @param {string} url URL of source code.\n     * @return {string} Source contents.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function loadSource(url) {\n        if (!TraceKit.remoteFetching) { //Only attempt request if remoteFetching is on.\n            return '';\n        }\n        try {\n            var getXHR = function() {\n                try {\n                    return new window.XMLHttpRequest();\n                } catch (e) {\n                    // explicitly bubble up the exception if not found\n                    return new window.ActiveXObject('Microsoft.XMLHTTP');\n                }\n            };\n\n            var request = getXHR();\n            request.open('GET', url, false);\n            request.send('');\n            return request.responseText;\n        } catch (e) {\n            return '';\n        }\n    }\n\n    /**\n     * Retrieves source code from the source code cache.\n     * @param {string} url URL of source code.\n     * @return {Array.<string>} Source contents.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function getSource(url) {\n        if (typeof url !== 'string') {\n            return [];\n        }\n\n        if (!_has(sourceCache, url)) {\n            // URL needs to be able to fetched within the acceptable domain.  Otherwise,\n            // cross-domain errors will be triggered.\n            /*\n                Regex matches:\n                0 - Full Url\n                1 - Protocol\n                2 - Domain\n                3 - Port (Useful for internal applications)\n                4 - Path\n            */\n            var source = '';\n            var domain = '';\n            try { domain = window.document.domain; } catch (e) { }\n            var match = /(.*)\\:\\/\\/([^:\\/]+)([:\\d]*)\\/{0,1}([\\s\\S]*)/.exec(url);\n            if (match && match[2] === domain) {\n                source = loadSource(url);\n            }\n            sourceCache[url] = source ? source.split('\\n') : [];\n        }\n\n        return sourceCache[url];\n    }\n\n    /**\n     * Tries to use an externally loaded copy of source code to determine\n     * the name of a function by looking at the name of the variable it was\n     * assigned to, if any.\n     * @param {string} url URL of source code.\n     * @param {(string|number)} lineNo Line number in source code.\n     * @return {string} The function name, if discoverable.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function guessFunctionName(url, lineNo) {\n        var reFunctionArgNames = /function ([^(]*)\\(([^)]*)\\)/,\n            reGuessFunction = /['\"]?([0-9A-Za-z$_]+)['\"]?\\s*[:=]\\s*(function|eval|new Function)/,\n            line = '',\n            maxLines = 10,\n            source = getSource(url),\n            m;\n\n        if (!source.length) {\n            return UNKNOWN_FUNCTION;\n        }\n\n        // Walk backwards from the first line in the function until we find the line which\n        // matches the pattern above, which is the function definition\n        for (var i = 0; i < maxLines; ++i) {\n            line = source[lineNo - i] + line;\n\n            if (!_isUndefined(line)) {\n                if ((m = reGuessFunction.exec(line))) {\n                    return m[1];\n                } else if ((m = reFunctionArgNames.exec(line))) {\n                    return m[1];\n                }\n            }\n        }\n\n        return UNKNOWN_FUNCTION;\n    }\n\n    /**\n     * Retrieves the surrounding lines from where an exception occurred.\n     * @param {string} url URL of source code.\n     * @param {(string|number)} line Line number in source code to center around for context.\n     * @return {?Array.<string>} Lines of source code.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function gatherContext(url, line) {\n        var source = getSource(url);\n\n        if (!source.length) {\n            return null;\n        }\n\n        var context = [],\n            // linesBefore & linesAfter are inclusive with the offending line.\n            // if linesOfContext is even, there will be one extra line\n            //   *before* the offending line.\n            linesBefore = Math.floor(TraceKit.linesOfContext / 2),\n            // Add one extra line if linesOfContext is odd\n            linesAfter = linesBefore + (TraceKit.linesOfContext % 2),\n            start = Math.max(0, line - linesBefore - 1),\n            end = Math.min(source.length, line + linesAfter - 1);\n\n        line -= 1; // convert to 0-based index\n\n        for (var i = start; i < end; ++i) {\n            if (!_isUndefined(source[i])) {\n                context.push(source[i]);\n            }\n        }\n\n        return context.length > 0 ? context : null;\n    }\n\n    /**\n     * Escapes special characters, except for whitespace, in a string to be\n     * used inside a regular expression as a string literal.\n     * @param {string} text The string.\n     * @return {string} The escaped string literal.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function escapeRegExp(text) {\n        return text.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#]/g, '\\\\$&');\n    }\n\n    /**\n     * Escapes special characters in a string to be used inside a regular\n     * expression as a string literal. Also ensures that HTML entities will\n     * be matched the same as their literal friends.\n     * @param {string} body The string.\n     * @return {string} The escaped string.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function escapeCodeAsRegExpForMatchingInsideHTML(body) {\n        return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('\"', '(?:\"|&quot;)').replace(/\\s+/g, '\\\\s+');\n    }\n\n    /**\n     * Determines where a code fragment occurs in the source code.\n     * @param {RegExp} re The function definition.\n     * @param {Array.<string>} urls A list of URLs to search.\n     * @return {?Object.<string, (string|number)>} An object containing\n     * the url, line, and column number of the defined function.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function findSourceInUrls(re, urls) {\n        var source, m;\n        for (var i = 0, j = urls.length; i < j; ++i) {\n            if ((source = getSource(urls[i])).length) {\n                source = source.join('\\n');\n                if ((m = re.exec(source))) {\n\n                    return {\n                        'url': urls[i],\n                        'line': source.substring(0, m.index).split('\\n').length,\n                        'column': m.index - source.lastIndexOf('\\n', m.index) - 1\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Determines at which column a code fragment occurs on a line of the\n     * source code.\n     * @param {string} fragment The code fragment.\n     * @param {string} url The URL to search.\n     * @param {(string|number)} line The line number to examine.\n     * @return {?number} The column number.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function findSourceInLine(fragment, url, line) {\n        var source = getSource(url),\n            re = new RegExp('\\\\b' + escapeRegExp(fragment) + '\\\\b'),\n            m;\n\n        line -= 1;\n\n        if (source && source.length > line && (m = re.exec(source[line]))) {\n            return m.index;\n        }\n\n        return null;\n    }\n\n    /**\n     * Determines where a function was defined within the source code.\n     * @param {(Function|string)} func A function reference or serialized\n     * function definition.\n     * @return {?Object.<string, (string|number)>} An object containing\n     * the url, line, and column number of the defined function.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function findSourceByFunctionBody(func) {\n        if (_isUndefined(window && window.document)) {\n            return;\n        }\n\n        var urls = [window.location.href],\n            scripts = window.document.getElementsByTagName('script'),\n            body,\n            code = '' + func,\n            codeRE = /^function(?:\\s+([\\w$]+))?\\s*\\(([\\w\\s,]*)\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/,\n            eventRE = /^function on([\\w$]+)\\s*\\(event\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/,\n            re,\n            parts,\n            result;\n\n        for (var i = 0; i < scripts.length; ++i) {\n            var script = scripts[i];\n            if (script.src) {\n                urls.push(script.src);\n            }\n        }\n\n        if (!(parts = codeRE.exec(code))) {\n            re = new RegExp(escapeRegExp(code).replace(/\\s+/g, '\\\\s+'));\n        }\n\n        // not sure if this is really necessary, but I dont have a test\n        // corpus large enough to confirm that and it was in the original.\n        else {\n            var name = parts[1] ? '\\\\s+' + parts[1] : '',\n                args = parts[2].split(',').join('\\\\s*,\\\\s*');\n\n            body = escapeRegExp(parts[3]).replace(/;$/, ';?'); // semicolon is inserted if the function ends with a comment.replace(/\\s+/g, '\\\\s+');\n            re = new RegExp('function' + name + '\\\\s*\\\\(\\\\s*' + args + '\\\\s*\\\\)\\\\s*{\\\\s*' + body + '\\\\s*}');\n        }\n\n        // look for a normal function definition\n        if ((result = findSourceInUrls(re, urls))) {\n            return result;\n        }\n\n        // look for an old-school event handler function\n        if ((parts = eventRE.exec(code))) {\n            var event = parts[1];\n            body = escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);\n\n            // look for a function defined in HTML as an onXXX handler\n            re = new RegExp('on' + event + '=[\\\\\\'\"]\\\\s*' + body + '\\\\s*[\\\\\\'\"]', 'i');\n\n            if ((result = findSourceInUrls(re, urls[0]))) {\n                return result;\n            }\n\n            // look for ???\n            re = new RegExp(body);\n\n            if ((result = findSourceInUrls(re, urls))) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    // Contents of Exception in various browsers.\n    //\n    // SAFARI:\n    // ex.message = Can't find variable: qq\n    // ex.line = 59\n    // ex.sourceId = 580238192\n    // ex.sourceURL = http://...\n    // ex.expressionBeginOffset = 96\n    // ex.expressionCaretOffset = 98\n    // ex.expressionEndOffset = 98\n    // ex.name = ReferenceError\n    //\n    // FIREFOX:\n    // ex.message = qq is not defined\n    // ex.fileName = http://...\n    // ex.lineNumber = 59\n    // ex.columnNumber = 69\n    // ex.stack = ...stack trace... (see the example below)\n    // ex.name = ReferenceError\n    //\n    // CHROME:\n    // ex.message = qq is not defined\n    // ex.name = ReferenceError\n    // ex.type = not_defined\n    // ex.arguments = ['aa']\n    // ex.stack = ...stack trace...\n    //\n    // INTERNET EXPLORER:\n    // ex.message = ...\n    // ex.name = ReferenceError\n    //\n    // OPERA:\n    // ex.message = ...message... (see the example below)\n    // ex.name = ReferenceError\n    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n    /**\n     * Computes stack trace information from the stack property.\n     * Chrome and Gecko use this property.\n     * @param {Error} ex\n     * @return {?TraceKit.StackTrace} Stack trace information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceFromStackProp(ex) {\n        if (!ex.stack) {\n            return null;\n        }\n\n        var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i,\n            gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i,\n            winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i,\n\n            // Used to additionally parse URL/line/column from eval frames\n            isEval,\n            geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i,\n            chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/,\n\n            lines = ex.stack.split('\\n'),\n            stack = [],\n            submatch,\n            parts,\n            element,\n            reference = /^(.*) is undefined$/.exec(ex.message);\n\n        for (var i = 0, j = lines.length; i < j; ++i) {\n            if ((parts = chrome.exec(lines[i]))) {\n                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n                isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n                if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n                    // throw out eval line/column and use top-most line/column number\n                    parts[2] = submatch[1]; // url\n                    parts[3] = submatch[2]; // line\n                    parts[4] = submatch[3]; // column\n                }\n                element = {\n                    'url': !isNative ? parts[2] : null,\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': isNative ? [parts[2]] : [],\n                    'line': parts[3] ? +parts[3] : null,\n                    'column': parts[4] ? +parts[4] : null\n                };\n            } else if ( parts = winjs.exec(lines[i]) ) {\n                element = {\n                    'url': parts[2],\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': [],\n                    'line': +parts[3],\n                    'column': parts[4] ? +parts[4] : null\n                };\n            } else if ((parts = gecko.exec(lines[i]))) {\n                isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n                if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n                    // throw out eval line/column and use top-most line number\n                    parts[3] = submatch[1];\n                    parts[4] = submatch[2];\n                    parts[5] = null; // no column when eval\n                } else if (i === 0 && !parts[5] && !_isUndefined(ex.columnNumber)) {\n                    // FireFox uses this awesome columnNumber property for its top frame\n                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n                    // so adding 1\n                    // NOTE: this hack doesn't work if top-most frame is eval\n                    stack[0].column = ex.columnNumber + 1;\n                }\n                element = {\n                    'url': parts[3],\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': parts[2] ? parts[2].split(',') : [],\n                    'line': parts[4] ? +parts[4] : null,\n                    'column': parts[5] ? +parts[5] : null\n                };\n            } else {\n                continue;\n            }\n\n            if (!element.func && element.line) {\n                element.func = guessFunctionName(element.url, element.line);\n            }\n\n            element.context = element.line ? gatherContext(element.url, element.line) : null;\n            stack.push(element);\n        }\n\n        if (!stack.length) {\n            return null;\n        }\n\n        if (stack[0] && stack[0].line && !stack[0].column && reference) {\n            stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);\n        }\n\n        return {\n            'mode': 'stack',\n            'name': ex.name,\n            'message': ex.message,\n            'stack': stack\n        };\n    }\n\n    /**\n     * Computes stack trace information from the stacktrace property.\n     * Opera 10+ uses this property.\n     * @param {Error} ex\n     * @return {?TraceKit.StackTrace} Stack trace information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceFromStacktraceProp(ex) {\n        // Access and store the stacktrace property before doing ANYTHING\n        // else to it because Opera is not very good at providing it\n        // reliably in other circumstances.\n        var stacktrace = ex.stacktrace;\n        if (!stacktrace) {\n            return;\n        }\n\n        var opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i,\n            opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i,\n            lines = stacktrace.split('\\n'),\n            stack = [],\n            parts;\n\n        for (var line = 0; line < lines.length; line += 2) {\n            var element = null;\n            if ((parts = opera10Regex.exec(lines[line]))) {\n                element = {\n                    'url': parts[2],\n                    'line': +parts[1],\n                    'column': null,\n                    'func': parts[3],\n                    'args':[]\n                };\n            } else if ((parts = opera11Regex.exec(lines[line]))) {\n                element = {\n                    'url': parts[6],\n                    'line': +parts[1],\n                    'column': +parts[2],\n                    'func': parts[3] || parts[4],\n                    'args': parts[5] ? parts[5].split(',') : []\n                };\n            }\n\n            if (element) {\n                if (!element.func && element.line) {\n                    element.func = guessFunctionName(element.url, element.line);\n                }\n                if (element.line) {\n                    try {\n                        element.context = gatherContext(element.url, element.line);\n                    } catch (exc) {}\n                }\n\n                if (!element.context) {\n                    element.context = [lines[line + 1]];\n                }\n\n                stack.push(element);\n            }\n        }\n\n        if (!stack.length) {\n            return null;\n        }\n\n        return {\n            'mode': 'stacktrace',\n            'name': ex.name,\n            'message': ex.message,\n            'stack': stack\n        };\n    }\n\n    /**\n     * NOT TESTED.\n     * Computes stack trace information from an error message that includes\n     * the stack trace.\n     * Opera 9 and earlier use this method if the option to show stack\n     * traces is turned on in opera:config.\n     * @param {Error} ex\n     * @return {?TraceKit.StackTrace} Stack information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceFromOperaMultiLineMessage(ex) {\n        // TODO: Clean this function up\n        // Opera includes a stack trace into the exception message. An example is:\n        //\n        // Statement on line 3: Undefined variable: undefinedFunc\n        // Backtrace:\n        //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\n        //         undefinedFunc(a);\n        //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\n        //           zzz(x, y, z);\n        //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\n        //           yyy(a, a, a);\n        //   Line 1 of function script\n        //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\n        //   ...\n\n        var lines = ex.message.split('\\n');\n        if (lines.length < 4) {\n            return null;\n        }\n\n        var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\n            lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\n            lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i,\n            stack = [],\n            scripts = (window && window.document && window.document.getElementsByTagName('script')),\n            inlineScriptBlocks = [],\n            parts;\n\n        for (var s in scripts) {\n            if (_has(scripts, s) && !scripts[s].src) {\n                inlineScriptBlocks.push(scripts[s]);\n            }\n        }\n\n        for (var line = 2; line < lines.length; line += 2) {\n            var item = null;\n            if ((parts = lineRE1.exec(lines[line]))) {\n                item = {\n                    'url': parts[2],\n                    'func': parts[3],\n                    'args': [],\n                    'line': +parts[1],\n                    'column': null\n                };\n            } else if ((parts = lineRE2.exec(lines[line]))) {\n                item = {\n                    'url': parts[3],\n                    'func': parts[4],\n                    'args': [],\n                    'line': +parts[1],\n                    'column': null // TODO: Check to see if inline#1 (+parts[2]) points to the script number or column number.\n                };\n                var relativeLine = (+parts[1]); // relative to the start of the <SCRIPT> block\n                var script = inlineScriptBlocks[parts[2] - 1];\n                if (script) {\n                    var source = getSource(item.url);\n                    if (source) {\n                        source = source.join('\\n');\n                        var pos = source.indexOf(script.innerText);\n                        if (pos >= 0) {\n                            item.line = relativeLine + source.substring(0, pos).split('\\n').length;\n                        }\n                    }\n                }\n            } else if ((parts = lineRE3.exec(lines[line]))) {\n                var url = window.location.href.replace(/#.*$/, '');\n                var re = new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[line + 1]));\n                var src = findSourceInUrls(re, [url]);\n                item = {\n                    'url': url,\n                    'func': '',\n                    'args': [],\n                    'line': src ? src.line : parts[1],\n                    'column': null\n                };\n            }\n\n            if (item) {\n                if (!item.func) {\n                    item.func = guessFunctionName(item.url, item.line);\n                }\n                var context = gatherContext(item.url, item.line);\n                var midline = (context ? context[Math.floor(context.length / 2)] : null);\n                if (context && midline.replace(/^\\s*/, '') === lines[line + 1].replace(/^\\s*/, '')) {\n                    item.context = context;\n                } else {\n                    // if (context) alert(\"Context mismatch. Correct midline:\\n\" + lines[i+1] + \"\\n\\nMidline:\\n\" + midline + \"\\n\\nContext:\\n\" + context.join(\"\\n\") + \"\\n\\nURL:\\n\" + item.url);\n                    item.context = [lines[line + 1]];\n                }\n                stack.push(item);\n            }\n        }\n        if (!stack.length) {\n            return null; // could not parse multiline exception message as Opera stack trace\n        }\n\n        return {\n            'mode': 'multiline',\n            'name': ex.name,\n            'message': lines[0],\n            'stack': stack\n        };\n    }\n\n    /**\n     * Adds information about the first frame to incomplete stack traces.\n     * Safari and IE require this to get complete data on the first frame.\n     * @param {TraceKit.StackTrace} stackInfo Stack trace information from\n     * one of the compute* methods.\n     * @param {string} url The URL of the script that caused an error.\n     * @param {(number|string)} lineNo The line number of the script that\n     * caused an error.\n     * @param {string=} message The error generated by the browser, which\n     * hopefully contains the name of the object that caused the error.\n     * @return {boolean} Whether or not the stack information was\n     * augmented.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n        var initial = {\n            'url': url,\n            'line': lineNo\n        };\n\n        if (initial.url && initial.line) {\n            stackInfo.incomplete = false;\n\n            if (!initial.func) {\n                initial.func = guessFunctionName(initial.url, initial.line);\n            }\n\n            if (!initial.context) {\n                initial.context = gatherContext(initial.url, initial.line);\n            }\n\n            var reference = / '([^']+)' /.exec(message);\n            if (reference) {\n                initial.column = findSourceInLine(reference[1], initial.url, initial.line);\n            }\n\n            if (stackInfo.stack.length > 0) {\n                if (stackInfo.stack[0].url === initial.url) {\n                    if (stackInfo.stack[0].line === initial.line) {\n                        return false; // already in stack trace\n                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n                        stackInfo.stack[0].line = initial.line;\n                        stackInfo.stack[0].context = initial.context;\n                        return false;\n                    }\n                }\n            }\n\n            stackInfo.stack.unshift(initial);\n            stackInfo.partial = true;\n            return true;\n        } else {\n            stackInfo.incomplete = true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Computes stack trace information by walking the arguments.caller\n     * chain at the time the exception occurred. This will cause earlier\n     * frames to be missed but is the only way to get any stack trace in\n     * Safari and IE. The top frame is restored by\n     * {@link augmentStackTraceWithInitialElement}.\n     * @param {Error} ex\n     * @return {TraceKit.StackTrace=} Stack trace information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceByWalkingCallerChain(ex, depth) {\n        var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n            stack = [],\n            funcs = {},\n            recursion = false,\n            parts,\n            item,\n            source;\n\n        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n            if (curr === computeStackTrace || curr === TraceKit.report) {\n                continue;\n            }\n\n            item = {\n                'url': null,\n                'func': UNKNOWN_FUNCTION,\n                'args': [],\n                'line': null,\n                'column': null\n            };\n\n            if (curr.name) {\n                item.func = curr.name;\n            } else if ((parts = functionName.exec(curr.toString()))) {\n                item.func = parts[1];\n            }\n\n            if (typeof item.func === 'undefined') {\n              try {\n                item.func = parts.input.substring(0, parts.input.indexOf('{'));\n              } catch (e) { }\n            }\n\n            if ((source = findSourceByFunctionBody(curr))) {\n                item.url = source.url;\n                item.line = source.line;\n\n                if (item.func === UNKNOWN_FUNCTION) {\n                    item.func = guessFunctionName(item.url, item.line);\n                }\n\n                var reference = / '([^']+)' /.exec(ex.message || ex.description);\n                if (reference) {\n                    item.column = findSourceInLine(reference[1], source.url, source.line);\n                }\n            }\n\n            if (funcs['' + curr]) {\n                recursion = true;\n            }else{\n                funcs['' + curr] = true;\n            }\n\n            stack.push(item);\n        }\n\n        if (depth) {\n            stack.splice(0, depth);\n        }\n\n        var result = {\n            'mode': 'callers',\n            'name': ex.name,\n            'message': ex.message,\n            'stack': stack\n        };\n        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n        return result;\n    }\n\n    /**\n     * Computes a stack trace for an exception.\n     * @param {Error} ex\n     * @param {(string|number)=} depth\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTrace(ex, depth) {\n        var stack = null;\n        depth = (depth == null ? 0 : +depth);\n\n        try {\n            // This must be tried first because Opera 10 *destroys*\n            // its stacktrace property if you try to access the stack\n            // property first!!\n            stack = computeStackTraceFromStacktraceProp(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceFromStackProp(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceFromOperaMultiLineMessage(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        return {\n            'name': ex.name,\n            'message': ex.message,\n            'mode': 'failed'\n        };\n    }\n\n    /**\n     * Logs a stacktrace starting from the previous call and working down.\n     * @param {(number|string)=} depth How many frames deep to trace.\n     * @return {TraceKit.StackTrace} Stack trace information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceOfCaller(depth) {\n        depth = (depth == null ? 0 : +depth) + 1; // \"+ 1\" because \"ofCaller\" should drop one frame\n        try {\n            throw new Error();\n        } catch (ex) {\n            return computeStackTrace(ex, depth + 1);\n        }\n    }\n\n    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n    computeStackTrace.guessFunctionName = guessFunctionName;\n    computeStackTrace.gatherContext = gatherContext;\n    computeStackTrace.ofCaller = computeStackTraceOfCaller;\n    computeStackTrace.getSource = getSource;\n\n    return computeStackTrace;\n}());\n\n/**\n * Extends support for global error handling for asynchronous browser\n * functions. Adopted from Closure Library's errorhandler.js\n * @memberof TraceKit\n */\nTraceKit.extendToAsynchronousCallbacks = function () {\n    var _helper = function _helper(fnName) {\n        var originalFn = window[fnName];\n        window[fnName] = function traceKitAsyncExtension() {\n            // Make a copy of the arguments\n            var args = _slice.call(arguments);\n            var originalCallback = args[0];\n            if (typeof (originalCallback) === 'function') {\n                args[0] = TraceKit.wrap(originalCallback);\n            }\n            // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it\n            // also only supports 2 argument and doesn't care what \"this\" is, so we\n            // can just call the original function directly.\n            if (originalFn.apply) {\n                return originalFn.apply(this, args);\n            } else {\n                return originalFn(args[0], args[1]);\n            }\n        };\n    };\n\n    _helper('setTimeout');\n    _helper('setInterval');\n};\n\n//Default options:\nif (!TraceKit.remoteFetching) {\n    TraceKit.remoteFetching = true;\n}\nif (!TraceKit.collectWindowErrors) {\n    TraceKit.collectWindowErrors = true;\n}\nif (!TraceKit.linesOfContext || TraceKit.linesOfContext < 1) {\n    // 5 lines before, the offending line, 5 lines after\n    TraceKit.linesOfContext = 11;\n}\n\n// UMD export\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (TraceKit),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else if (typeof module !== 'undefined' && module.exports && window.module !== module) {\n    module.exports = TraceKit;\n} else {\n    window.TraceKit = TraceKit;\n}\n\n}(typeof window !== 'undefined' ? window : global));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar levels = ['log', 'info', 'warn', 'error'];\r\nvar originalLevels = {};\r\nlevels.forEach(function (level) { return originalLevels[level] = console[level]; });\r\nvar levelColors = {\r\n    qiniu: '#29a8e1',\r\n    normal: '#333',\r\n    log: '#86C166',\r\n    info: '#006284',\r\n    warn: '#CA7A2C',\r\n    error: '#CB1B45' // KURUNAI\r\n};\r\nvar logger = {};\r\nlevels.forEach(function (level) { return logger[level] = function (message) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    if (typeof message !== 'string' || args.length > 0) {\r\n        return originalLevels[level].apply(console, [message].concat(args));\r\n    }\r\n    return originalLevels[level].call(console, \"%c[RAVEN-DEBUG] %c[\" + level.toUpperCase() + \"] %c\" + message, \"color: \" + levelColors.qiniu, \"color: \" + levelColors[level], \"color: \" + levelColors.normal);\r\n}; });\r\nexports.default = logger;\r\n// TODO: Logger could be a devtools \r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar raven_1 = __webpack_require__(9);\r\nmodule.exports = raven_1.default;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TraceKit = __webpack_require__(6);\r\n// Detection\r\nvar detection_1 = __webpack_require__(1);\r\n// Store\r\nvar store_1 = __webpack_require__(3);\r\nvar messages_store_1 = __webpack_require__(10);\r\n// Transfer\r\nvar transfer_1 = __webpack_require__(5);\r\n// Sources\r\nvar source_1 = __webpack_require__(2);\r\nvar xhr_1 = __webpack_require__(11);\r\nvar console_1 = __webpack_require__(12);\r\nvar history_1 = __webpack_require__(13);\r\nvar ui_event_1 = __webpack_require__(14);\r\nvar exception_1 = __webpack_require__(15);\r\n// Logger\r\nvar logger_1 = __webpack_require__(7);\r\nvar utils_1 = __webpack_require__(0);\r\nvar DEFAULT_RAVEN_OPTION = {\r\n    environment: 'production',\r\n    autoInstall: true,\r\n    instrument: {\r\n        tryCatch: true\r\n    },\r\n    autoBreadcrumbs: {\r\n        xhr: true,\r\n        console: true,\r\n        dom: true,\r\n        history: true\r\n    }\r\n};\r\nvar Raven = (function () {\r\n    /**\r\n     * Raven Constructor\r\n     * @param option Raven Option\r\n     */\r\n    function Raven(option) {\r\n        if (option === void 0) { option = {}; }\r\n        this.callbacks = {};\r\n        this.configStore = new store_1.Store('config');\r\n        this.contextStore = new store_1.Store('context');\r\n        this.messages = new messages_store_1.MessagesStore(this);\r\n        this.transfers = [];\r\n        this.sources = [];\r\n        this.__wrappedBuiltins = [];\r\n        this._ignoreOnError = 0;\r\n        this.option = utils_1.merge(utils_1.clone(DEFAULT_RAVEN_OPTION), option);\r\n        if (this.option.debug) {\r\n            this.debug = true;\r\n        }\r\n        // Set Up\r\n        if (this.option.release) {\r\n            this.setRelease(this.option.release);\r\n        }\r\n        if (this.option.environment) {\r\n            this.setEnvironment(this.option.environment);\r\n        }\r\n        if (this.option.transfer) {\r\n            this.addTransfer(this.option.transfer);\r\n        }\r\n        if (this.option.transfers) {\r\n            for (var _i = 0, _a = this.option.transfers; _i < _a.length; _i++) {\r\n                var transfer = _a[_i];\r\n                this.addTransfer(transfer);\r\n            }\r\n        }\r\n        if (this.option.sources) {\r\n            for (var _b = 0, _c = this.option.sources; _b < _c.length; _b++) {\r\n                var source = _c[_b];\r\n                this.addSource(source);\r\n            }\r\n        }\r\n        if (this.option.autoInstall) {\r\n            this.install();\r\n        }\r\n    }\r\n    Object.defineProperty(Raven.prototype, \"Transfer\", {\r\n        get: function () {\r\n            return transfer_1.default;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Raven.prototype, \"Source\", {\r\n        get: function () {\r\n            return source_1.default;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Raven.prototype, \"logger\", {\r\n        get: function () {\r\n            return logger_1.default;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Raven.prototype, \"debug\", {\r\n        /**\r\n         * getter debug\r\n         * @return {boolean}\r\n         */\r\n        get: function () {\r\n            return this.configStore.get('debug') || false;\r\n        },\r\n        /**\r\n         * setter debug\r\n         */\r\n        set: function (value) {\r\n            if (value === true) {\r\n                logger_1.default.info(\"[CONFIG] set debug = \" + value);\r\n            }\r\n            this.configStore.set('debug', value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Install raven's instruments\r\n     * @return {Raven}\r\n     */\r\n    Raven.prototype.install = function () {\r\n        var _this = this;\r\n        // Instrument TryCatch\r\n        if (this.option.instrument && this.option.instrument['tryCatch']) {\r\n            this.addSource(exception_1.default());\r\n            if (detection_1._window) {\r\n                detection_1._window.onerror = function (msg, source, line, col, err) {\r\n                    _this.captureException(err);\r\n                };\r\n            }\r\n        }\r\n        // Instrumeny Breadcrumb\r\n        if (this.option.autoBreadcrumbs) {\r\n            this._setupBreadcrumb();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Dispose raven\r\n     * @return {Raven}\r\n     */\r\n    Raven.prototype.uninstall = function () {\r\n        // Restore wrapped builtins\r\n        this._restoreBuiltIns();\r\n        // Dispose all sources\r\n        this.sources.forEach(function (source) { return source.dispose(); });\r\n        return this;\r\n    };\r\n    /**\r\n     * Add new source into raven\r\n     *\r\n     * @param {Source} source Data source\r\n     * @return {Raven}\r\n     *\r\n     * @example\r\n     * raven.addSource(source)\r\n     */\r\n    Raven.prototype.addSource = function (source) {\r\n        var _this = this;\r\n        if (!source)\r\n            return;\r\n        source.onAction(function (message) { return _this.messages.add(message); });\r\n        this.sources.push(source);\r\n        if (this.debug) {\r\n            this.logger.info(\"[SOURCE] added source \" + source.name);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * add a data transfer\r\n     *\r\n     * @param {Transfer} transfer Custom data transfer\r\n     * @return {Raven}\r\n     *\r\n     * @example\r\n     * raven.addTransfer(transfer)\r\n     */\r\n    Raven.prototype.addTransfer = function (transfer) {\r\n        transfer.config(this.configStore.toJS());\r\n        this.transfers.push(transfer);\r\n        if (this.debug) {\r\n            this.logger.info(\"[TRANSFER] added transfer \" + transfer.name);\r\n        }\r\n        return this;\r\n    };\r\n    Raven.prototype.config = function (keyOrObject, value) {\r\n        if (typeof keyOrObject === 'string') {\r\n            var key = keyOrObject;\r\n            this.configStore.set(key, value);\r\n            if (this.debug) {\r\n                this.logger.info(\"[CONFIG] set \" + key + \" = \" + value);\r\n            }\r\n        }\r\n        else {\r\n            for (var key in keyOrObject) {\r\n                if (keyOrObject.hasOwnProperty(key)) {\r\n                    var value_1 = keyOrObject[key];\r\n                    this.config(key, value_1);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Manually capture an exception and send it over to Sentry\r\n     *\r\n     * @param {error} ex An exception to be logged\r\n     * @param {object} options A specific set of options for this error [optional]\r\n     * @return {Raven}\r\n     *\r\n     * @example\r\n     * try {\r\n     *   // stuff...\r\n     * } catch(ex) {\r\n     *   raven.captureException(ex)\r\n     * }\r\n     *\r\n     * @example\r\n     * stuff().catch((ex) => raven.captureException(ex))\r\n     */\r\n    Raven.prototype.captureException = function (ex, options) {\r\n        if (options === void 0) { options = {}; }\r\n        // If not an Error is passed through, recall as a message instead\r\n        if (!utils_1.isError(ex)) {\r\n            return this.captureException(ex, utils_1.merge({\r\n                trimHeadFrames: 1,\r\n                stacktrace: true // if we fall back to captureMessage, default to attempting a new trace\r\n            }, options));\r\n        }\r\n        // TraceKit.report will re-raise any exception passed to it,\r\n        // which means you have to wrap it in try/catch. Instead, we\r\n        // can wrap it here and only re-raise if TraceKit.report\r\n        // raises an exception different from the one we asked to\r\n        // report on.\r\n        try {\r\n            TraceKit.report(ex);\r\n        }\r\n        catch (ex1) {\r\n            if (ex !== ex1) {\r\n                throw ex1;\r\n            }\r\n        }\r\n        if (this.debug) {\r\n            this.logger.error(\"[EXCEPTION] capture exception: \" + ex.message);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a user to be sent along with the payload.\r\n     *\r\n     * @param {object} user An object representing user data [optional]\r\n     * @return {Raven}\r\n     *\r\n     * @example\r\n     * raven.setUserContext({\r\n     *   uid: 123456,\r\n     *   email: 'foobar@example.com'\r\n     * })\r\n     */\r\n    Raven.prototype.setUserContext = function (user) {\r\n        var _this = this;\r\n        this.contextStore.set('user', user);\r\n        if (this.transfers.length > 0) {\r\n            this.transfers.forEach(function (transfer) { return transfer.config(_this.contextStore.toJS()); });\r\n        }\r\n        if (this.debug) {\r\n            this.logger.info(\"[CONTEXT] set user context: \" + user);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Merge tags to be sent along with the payload.\r\n     *\r\n     * @param {object} tags An object representing tags\r\n     * @return {Raven}\r\n     *\r\n     * @example\r\n     * raven.setTagsContext('tags', [ 'beta' ])\r\n     */\r\n    Raven.prototype.setTagsContext = function (tags) {\r\n        var _this = this;\r\n        this.contextStore.set('tags', tags);\r\n        if (this.transfers.length > 0) {\r\n            this.transfers.forEach(function (transfer) { return transfer.config(_this.contextStore.toJS()); });\r\n        }\r\n        if (this.debug) {\r\n            this.logger.info(\"[CONTEXT] set tags context: \" + tags);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Merge extra attributes to be sent along with the payload.\r\n     *\r\n     * @param {object} extra An object representing extra data [optional]\r\n     * @return {Raven}\r\n     */\r\n    Raven.prototype.setExtraContext = function (extra) {\r\n        var _this = this;\r\n        this.contextStore.set('extra', extra);\r\n        if (this.transfers.length > 0) {\r\n            this.transfers.forEach(function (transfer) { return transfer.config(_this.contextStore.toJS()); });\r\n        }\r\n        if (this.debug) {\r\n            this.logger.info(\"[CONTEXT] set extra context: \" + extra);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Clear all of the context.\r\n     *\r\n     * @return {Raven}\r\n     *\r\n     * @example\r\n     * raven.clearContext()\r\n     */\r\n    Raven.prototype.clearContext = function () {\r\n        this.contextStore.clear();\r\n        if (this.debug) {\r\n            this.logger.info(\"[CONTEXT] clear context\");\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Get a copy of the current context. This cannot be mutated.\r\n     *\r\n     * @return {object} copy of context\r\n     */\r\n    Raven.prototype.getContext = function () {\r\n        return this.contextStore.toJS();\r\n    };\r\n    /**\r\n     * Set environment of application\r\n     *\r\n     * @param {string} environment Typically something like 'production'.\r\n     * @return {Raven}\r\n     *\r\n     * @example\r\n     * raven.setEnvironment('development')\r\n     * raven.setEnvironment('production')\r\n     */\r\n    Raven.prototype.setEnvironment = function (env) {\r\n        this.contextStore.set('environment', env);\r\n        if (this.debug) {\r\n            this.logger.info(\"[CONTEXT] set environment context: \" + env);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Set release version of application\r\n     *\r\n     * @param {string} release Typically something like a git SHA to identify version\r\n     * @return {Raven}\r\n     *\r\n     * @example\r\n     * raven.setRelease('public-v0.1.0')\r\n     */\r\n    Raven.prototype.setRelease = function (release) {\r\n        this.contextStore.set('release', release);\r\n        if (this.debug) {\r\n            this.logger.info(\"[CONTEXT] set release context: \" + release);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Get the callback of the special point\r\n     *\r\n     * @param {string} key Key of callback\r\n     * @return {ValueCallback}\r\n     *\r\n     * @example\r\n     * raven.getCallback('breadcrumb')\r\n     */\r\n    Raven.prototype.getCallback = function (key) {\r\n        if (utils_1.isNil(this.callbacks[key])) {\r\n            return function () { return false; };\r\n        }\r\n        return this.callbacks[key];\r\n    };\r\n    /**\r\n     * Set callback of special point\r\n     *\r\n     * @param {string} key Key of the point\r\n     * @param {ValueCallback} callback Callback\r\n     *\r\n     * @example\r\n     * raven.setCallback('breadcrumb', (message) => {\r\n     *   console.log(message)\r\n     * })\r\n     */\r\n    Raven.prototype.setCallback = function (key, callback) {\r\n        if (utils_1.isUndefined(callback)) {\r\n            this.callbacks[key] = null;\r\n            if (this.debug) {\r\n                logger_1.default.info(\"[CALLBACK] remove \" + key + \" callback\");\r\n            }\r\n        }\r\n        else if (utils_1.isFunction(callback)) {\r\n            this.callbacks[key] = callback;\r\n            if (this.debug) {\r\n                logger_1.default.info(\"[CALLBACK] set \" + key + \" callback\");\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Set the breadcrumb callback option\r\n     *\r\n     * @param {ValueCallback} callback The callback to run which some breadcrumb\r\n     *                            message create\r\n     * @return {Raven}\r\n     */\r\n    Raven.prototype.setBreadcrumbCallback = function (callback) {\r\n        var original = this.getCallback('breadcrumb');\r\n        this.setCallback('breadcrumb', composeCallback(original, callback));\r\n    };\r\n    /**\r\n     * Set the dataCallback option\r\n     *\r\n     * @param {ValueCallback} callback The callback to run which some exception\r\n     *                            message create\r\n     * @return {Raven}\r\n     */\r\n    Raven.prototype.setExceptionCallback = function (callback) {\r\n        var original = this.getCallback('exception');\r\n        this.setCallback('exception', composeCallback(original, callback));\r\n    };\r\n    /**\r\n     * Wrap code within a context and returns back a new function to be executed\r\n     *\r\n     * @param {object} options A specific set of options for this context [optional]\r\n     * @param {function} func The function to be wrapped in a new context\r\n     * @param {function} func A function to call before the try/catch wrapper [optional, private]\r\n     * @return {function} The newly wrapped functions with a context\r\n     */\r\n    Raven.prototype.wrap = function (options, func, _before) {\r\n        // 1 argument has been passed, and it's not a function\r\n        // so just return it\r\n        if (utils_1.isUndefined(func) && !utils_1.isFunction(options)) {\r\n            return options;\r\n        }\r\n        // option is optional\r\n        if (utils_1.isFunction(options)) {\r\n            func = options;\r\n            options = undefined;\r\n        }\r\n        // At this point, we've passed along 2 arguments, and the second one\r\n        // is not a function either, so we'll just return the second argument.\r\n        if (!utils_1.isFunction(func)) {\r\n            return func;\r\n        }\r\n        // We don't wanna wrap it twice!\r\n        try {\r\n            if (func.__raven__) {\r\n                return func;\r\n            }\r\n            // If this has already been wrapped in the past, return that\r\n            if (func.__raven_wrapper__) {\r\n                return func.__raven_wrapper__;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Just accessing custom props in some Selenium environments\r\n            // can cause a \"Permission denied\" exception (see raven-js#495).\r\n            // Bail on wrapping and return the function as-is (defers to window.onerror).\r\n            return func;\r\n        }\r\n        var self = this;\r\n        function wrapped() {\r\n            var args = [], i = arguments.length, deep = !options || options && options.deep !== false;\r\n            if (_before && utils_1.isFunction(_before)) {\r\n                _before.apply(this, arguments);\r\n            }\r\n            // Recursively wrap all of a function's arguments that are\r\n            // functions themselves.\r\n            while (i--)\r\n                args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];\r\n            try {\r\n                // Attempt to invoke user-land function\r\n                // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\r\n                //       means Raven caught an error invoking your application code. This is\r\n                //       expected behavior and NOT indicative of a bug with Raven.js.\r\n                return func.apply(this, args);\r\n            }\r\n            catch (e) {\r\n                self._ignoreNextOnError();\r\n                self.captureException(e, options);\r\n                throw e;\r\n            }\r\n        }\r\n        for (var prop in func) {\r\n            if (utils_1.hasKey(func, prop)) {\r\n                wrapped[prop] = func[prop];\r\n            }\r\n        }\r\n        wrapped.prototype = func.prototype;\r\n        func.__raven_wrapper__ = wrapped;\r\n        wrapped['__raven__'] = true;\r\n        wrapped['__inner__'] = func;\r\n        if (this.debug) {\r\n            var funcName = func.name || 'anynomous';\r\n            logger_1.default.info(\"wrap function \" + funcName);\r\n        }\r\n        return wrapped;\r\n    };\r\n    Raven.prototype.context = function (func, argsOrOptions, options) {\r\n        var args = null;\r\n        var opts = undefined;\r\n        switch (true) {\r\n            case utils_1.isArray(argsOrOptions) && utils_1.isUndefined(options):// overload +1\r\n                args = argsOrOptions;\r\n                break;\r\n            case !utils_1.isArray(argsOrOptions) && utils_1.isUndefined(options):// overload +2\r\n                args = [];\r\n                opts = argsOrOptions;\r\n                break;\r\n            case utils_1.isArray(argsOrOptions) && !utils_1.isUndefined(options):// overload +3\r\n                args = argsOrOptions;\r\n                opts = options;\r\n                break;\r\n        }\r\n        return this.wrap(options, func).apply(this, args);\r\n    };\r\n    Raven.prototype._ignoreNextOnError = function () {\r\n        var _this = this;\r\n        this._ignoreOnError += 1;\r\n        setTimeout(function () {\r\n            _this._ignoreOnError -= 1;\r\n        });\r\n    };\r\n    Raven.prototype._setupBreadcrumb = function () {\r\n        if (this.option.autoBreadcrumbs['xhr'] || this.option.autoBreadcrumbs === true) {\r\n            this.addSource(xhr_1.default(this));\r\n        }\r\n        if (this.option.autoBreadcrumbs['history'] || this.option.autoBreadcrumbs === true) {\r\n            this.addSource(history_1.default(this));\r\n        }\r\n        if (this.option.autoBreadcrumbs['dom'] || this.option.autoBreadcrumbs === true) {\r\n            this.addSource(ui_event_1.default());\r\n        }\r\n        if (this.option.autoBreadcrumbs['console'] || this.option.autoBreadcrumbs === true) {\r\n            this.addSource(console_1.default());\r\n        }\r\n    };\r\n    Raven.prototype._restoreBuiltIns = function () {\r\n        for (var _i = 0, _a = this.__wrappedBuiltins; _i < _a.length; _i++) {\r\n            var _b = _a[_i], obj = _b[0], name_1 = _b[1], orig = _b[2];\r\n            obj[name_1] = orig;\r\n        }\r\n    };\r\n    return Raven;\r\n}());\r\nexports.Raven = Raven;\r\nvar raven = new Raven(detection_1._window.raven_option || {});\r\nexports.default = raven;\r\nfunction composeCallback(original, callback) {\r\n    return utils_1.isFunction(callback)\r\n        ? function (data) { return callback(data, original); }\r\n        : callback;\r\n}\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar store_1 = __webpack_require__(3);\r\nvar detection_1 = __webpack_require__(1);\r\nvar logger_1 = __webpack_require__(7);\r\nvar breadcrumbCategories = ['console', 'history', 'ui.events', 'network'];\r\nvar isBreadcrumb = function (category) {\r\n    return breadcrumbCategories.indexOf(category) >= 0;\r\n};\r\nvar MessagesStore = (function () {\r\n    function MessagesStore(parent) {\r\n        this.counter = 0;\r\n        this.store = new store_1.CollectionStore('messages');\r\n        this.parent = parent;\r\n    }\r\n    MessagesStore.prototype.add = function (data) {\r\n        if (detection_1._window && detection_1._window.location && detection_1._window.location.href) {\r\n            data.url = detection_1._window.location.href;\r\n        }\r\n        var message = {\r\n            id: ++this.counter,\r\n            data: data,\r\n            sent: false\r\n        };\r\n        this.store.push(message);\r\n        this.parent.transfers.forEach(function (transfer) { return transfer.send(message); });\r\n        if (isBreadcrumb(data.category)) {\r\n            this.parent.getCallback('breadcrumb')(data);\r\n        }\r\n        if (data.category === 'error') {\r\n            this.parent.getCallback('exception')(data);\r\n        }\r\n        if (this.parent.debug) {\r\n            logger_1.default.log(\"[MESSAGES] New message added [\" + data.category + \"], messages count: \" + this.store.length);\r\n            logger_1.default.log(\"[MESSAGES]\", data);\r\n        }\r\n    };\r\n    return MessagesStore;\r\n}());\r\nexports.MessagesStore = MessagesStore;\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar source_1 = __webpack_require__(2);\r\nvar utils_1 = __webpack_require__(0);\r\nvar detection_1 = __webpack_require__(1);\r\nfunction genXHRMessage(action, method, url, status_code) {\r\n    if (status_code === void 0) { status_code = null; }\r\n    return {\r\n        action: action, method: method, url: url, status_code: status_code, duration: 0\r\n    };\r\n}\r\nexports.default = function (raven) {\r\n    function wrapProp(prop, xhr) {\r\n        if (prop in xhr && utils_1.isFunction(xhr[prop])) {\r\n            utils_1.fill(xhr, prop, function (orig) { return raven.wrap(orig); }); // intentionally don't track filled methods on XHR instances\r\n        }\r\n    }\r\n    if (!detection_1._window)\r\n        return null;\r\n    return new source_1.default('breadcrumb.XHR', function (action) {\r\n        // XMLHttpRequest\r\n        if ('XMLHttpRequest' in detection_1._window) {\r\n            var xhrproto = XMLHttpRequest.prototype;\r\n            utils_1.fill(xhrproto, 'open', function (originFunc) {\r\n                return function (method, url) {\r\n                    this.__raven_xhr = genXHRMessage('open', method, url);\r\n                    return originFunc.apply(this, arguments);\r\n                };\r\n            }, raven.__wrappedBuiltins);\r\n            utils_1.fill(xhrproto, 'send', function (originFunc) {\r\n                return function (data) {\r\n                    var xhr = this;\r\n                    var startAt = Date.now();\r\n                    var timeChecker = setTimeout(function () { return action({\r\n                        category: 'network',\r\n                        payload: xhr.__raven_xhr\r\n                    }); }, 30 * 1000 /* 30 sec */);\r\n                    function onreadystatechangeHandler() {\r\n                        if (xhr.__raven_xhr && (xhr.readyState === 1 || xhr.readyState === 4)) {\r\n                            if (timeChecker) {\r\n                                clearTimeout(timeChecker);\r\n                            }\r\n                            try {\r\n                                // touching statusCode in some platforms throws\r\n                                // an exception\r\n                                xhr.__raven_xhr.status_code = xhr.status;\r\n                                xhr.__raven_xhr.duration = Date.now() - startAt;\r\n                            }\r\n                            catch (e) { }\r\n                            action({\r\n                                category: 'netword',\r\n                                payload: xhr.__raven_xhr\r\n                            });\r\n                        }\r\n                    }\r\n                    var props = ['onload', 'onerror', 'onprogress'];\r\n                    for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {\r\n                        var prop = props_1[_i];\r\n                        wrapProp(prop, xhr);\r\n                    }\r\n                    if ('onreadystatechange' in xhr && utils_1.isFunction(xhr.onreadystatechange)) {\r\n                        utils_1.fill(xhr, 'onreadystatechange', function (orig) { return raven.wrap(orig, undefined, onreadystatechangeHandler); });\r\n                    }\r\n                    else {\r\n                        xhr.onreadystatechange = onreadystatechangeHandler;\r\n                    }\r\n                    return originFunc.apply(this, arguments);\r\n                };\r\n            }, raven.__wrappedBuiltins);\r\n        }\r\n        // Fetch API\r\n        if ('fetch' in detection_1._window) {\r\n            detection_1._window['_origin_fetch'] = detection_1._window.fetch;\r\n            utils_1.fill(detection_1._window, 'fetch', function (origFetch) {\r\n                return function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    var fetchInput = args[0];\r\n                    var method = 'GET';\r\n                    var url = null;\r\n                    if (typeof fetchInput === 'string') {\r\n                        url = fetchInput;\r\n                    }\r\n                    else {\r\n                        url = fetchInput.url;\r\n                        if (fetchInput.method) {\r\n                            method = fetchInput.method;\r\n                        }\r\n                    }\r\n                    if (args[1] && args[1].method) {\r\n                        method = args[1].method;\r\n                    }\r\n                    var fetchData = {\r\n                        method: method, url: url, status_code: null, duration: 0\r\n                    };\r\n                    var startAt = Date.now();\r\n                    var timeChecker = setTimeout(function () { return action({\r\n                        category: 'network',\r\n                        payload: fetchData\r\n                    }); }, 30 * 1000 /* 30 sec */);\r\n                    return origFetch.apply(detection_1._window, args).then(function (resp) {\r\n                        if (timeChecker) {\r\n                            clearTimeout(timeChecker);\r\n                        }\r\n                        fetchData.status_code = resp.status;\r\n                        fetchData.duration = Date.now() - startAt;\r\n                        action({\r\n                            category: 'network',\r\n                            payload: fetchData\r\n                        });\r\n                        return resp;\r\n                    });\r\n                };\r\n            }, raven.__wrappedBuiltins);\r\n        }\r\n    });\r\n};\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar source_1 = __webpack_require__(2);\r\nfunction wrapMethod(console, level, callback) {\r\n    var originalConsoleLevel = console[level];\r\n    var originalConsole = console;\r\n    if (!(level in console)) {\r\n        return;\r\n    }\r\n    console[\"_origin_\" + level] = originalConsoleLevel;\r\n    console[level] = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var msg = args.join(' ');\r\n        var data = {\r\n            level: level,\r\n            logger: 'console',\r\n            extra: {\r\n                'arguments': args\r\n            }\r\n        };\r\n        if (originalConsoleLevel) {\r\n            Function.prototype.apply.call(originalConsoleLevel, originalConsole, args);\r\n        }\r\n        callback(msg, data);\r\n    };\r\n}\r\nexports.wrapMethod = wrapMethod;\r\nvar levels = ['debug', 'info', 'warn', 'error', 'log'];\r\nexports.default = function () {\r\n    return new source_1.default('breadcrumb.console', function (action) {\r\n        var consoleMethodCallback = function (msg, data) {\r\n            action({\r\n                category: 'console',\r\n                payload: {\r\n                    level: data.level,\r\n                    message: msg\r\n                }\r\n            });\r\n        };\r\n        for (var _i = 0, levels_1 = levels; _i < levels_1.length; _i++) {\r\n            var level = levels_1[_i];\r\n            wrapMethod(console, level, consoleMethodCallback);\r\n        }\r\n    });\r\n};\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar source_1 = __webpack_require__(2);\r\nvar utils_1 = __webpack_require__(0);\r\nvar detection_1 = __webpack_require__(1);\r\nexports.default = function (raven) {\r\n    if (!detection_1._window)\r\n        return;\r\n    var _location = detection_1._window.location;\r\n    var _lastHref = _location && _location.href;\r\n    // record navigation (URL) changes\r\n    // NOTE: in Chrome App environment, touching history.pushState, *even inside\r\n    //       a try/catch block*, will cause Chrome to output an error to console.error\r\n    // borrowed from: https://github.com/angular/angular.js/pull/13945/files\r\n    var chrome = detection_1._window.chrome;\r\n    var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;\r\n    var hasPushState = !isChromePackagedApp && detection_1._window.history && history.pushState;\r\n    if (!hasPushState)\r\n        return;\r\n    return new source_1.default('breadcrumb.history', function (action) {\r\n        if (detection_1._window && detection_1._navigator && detection_1._document) {\r\n            // Push a navigation message when page load\r\n            var message_1 = {\r\n                category: 'navigation',\r\n                payload: {\r\n                    to: _lastHref,\r\n                    pageView: true,\r\n                    pageSize: {\r\n                        width: detection_1._document.body.offsetWidth,\r\n                        height: detection_1._document.body.offsetHeight\r\n                    },\r\n                    screenSize: {\r\n                        width: detection_1._window.screen.width,\r\n                        height: detection_1._window.screen.height\r\n                    },\r\n                    userAgent: detection_1._navigator.userAgent\r\n                }\r\n            };\r\n            setTimeout(function () { return action(message_1); }, 1);\r\n        }\r\n        // TODO: remove onpopstate handler on uninstall()\r\n        var oldOnPopState = detection_1._window.onpopstate;\r\n        detection_1._window.onpopstate = function () {\r\n            var currentHref = _location.href;\r\n            var message = {\r\n                category: 'navigation',\r\n                payload: {\r\n                    to: currentHref,\r\n                    from: _lastHref\r\n                }\r\n            };\r\n            action(message);\r\n            _lastHref = currentHref;\r\n            if (oldOnPopState) {\r\n                return oldOnPopState.apply(history, arguments);\r\n            }\r\n        };\r\n        utils_1.fill(history, 'pushState', function (origPushState) {\r\n            // note history.pushState.length is 0; intentionally not declaring\r\n            // params to preserve 0 arity\r\n            return function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                var url = args.length > 2 ? args[2] : undefined;\r\n                // url argument is optional\r\n                if (url) {\r\n                    // coerce to string (this is what pushState does)\r\n                    var message = {\r\n                        category: 'navigation',\r\n                        payload: {\r\n                            to: url,\r\n                            from: _lastHref\r\n                        }\r\n                    };\r\n                    action(message);\r\n                    _lastHref = url;\r\n                }\r\n                return origPushState.apply(history, args);\r\n            };\r\n        }, raven.__wrappedBuiltins);\r\n    });\r\n};\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar source_1 = __webpack_require__(2);\r\nvar utils_1 = __webpack_require__(0);\r\nvar detection_1 = __webpack_require__(1);\r\nvar _keypressTimeout = null;\r\nvar _lastCapturedEvent = null;\r\nfunction domEventHandler(evtName, action) {\r\n    return function (evt) {\r\n        // reset keypress timeout; e.g. triggering a 'click' after\r\n        // a 'keypress' will reset the keypress debounce so that a new\r\n        // set of keypresses can be recorded\r\n        _keypressTimeout = null;\r\n        // It's possible this handler might trigger multiple times for the same\r\n        // event (e.g. event propagation through node ancestors). Ignore if we've\r\n        // already captured the event.\r\n        if (_lastCapturedEvent === evt)\r\n            return;\r\n        _lastCapturedEvent = evt;\r\n        // try/catch both:\r\n        // - accessing evt.target (see getsentry/raven-js#838, #768)\r\n        // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\r\n        //   can throw an exception in some circumstances.\r\n        var target = null;\r\n        try {\r\n            target = utils_1.htmlTreeAsString(evt.target);\r\n        }\r\n        catch (ex) {\r\n            target = '<unknown>';\r\n        }\r\n        var payload = {\r\n            event: evtName,\r\n            path: target\r\n        };\r\n        if (evtName === 'click' || evtName === 'touchstart') {\r\n            payload.pos = {\r\n                x: evt.pageX,\r\n                y: evt.pageY\r\n            };\r\n            payload.pageSize = {\r\n                width: detection_1._document.body.offsetWidth,\r\n                height: detection_1._document.body.offsetHeight\r\n            };\r\n        }\r\n        if (evtName === 'input') {\r\n            payload.value = evt.target.value;\r\n        }\r\n        action({\r\n            category: 'ui.events',\r\n            payload: payload\r\n        });\r\n    };\r\n}\r\nvar debounceDuration = 1000; // milliseconds\r\nfunction keypressHandler(action) {\r\n    return function (evt) {\r\n        var target;\r\n        try {\r\n            target = evt.target;\r\n        }\r\n        catch (e) {\r\n            // just accessing event properties can throw an exception in some rare circumstances\r\n            // see: https://github.com/getsentry/raven-js/issues/838\r\n            return;\r\n        }\r\n        var tagName = target && target.tagName;\r\n        // only consider keypress events on actual input elements\r\n        // this will disregard keypresses targeting body (e.g. tabbing\r\n        // through elements, hotkeys, etc)\r\n        if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)\r\n            return;\r\n        // record first keypress in a series, but ignore subsequent\r\n        // keypresses until debounce clears\r\n        var timeout = _keypressTimeout;\r\n        if (!timeout) {\r\n            domEventHandler('input', action)(evt);\r\n        }\r\n        clearTimeout(timeout);\r\n        _keypressTimeout = setTimeout(function () {\r\n            _keypressTimeout = null;\r\n        }, debounceDuration);\r\n    };\r\n}\r\nexports.default = function () {\r\n    if (!detection_1._document || !detection_1.hasDocument)\r\n        return;\r\n    return new source_1.default('breadcrumb.DOMEvents', function (action) {\r\n        if (detection_1._document.addEventListener) {\r\n            detection_1._document.addEventListener('click', domEventHandler('click', action), false);\r\n            detection_1._document.addEventListener('keypress', keypressHandler(action), false);\r\n        }\r\n        else {\r\n            // IE8 Compatibility\r\n            detection_1._document.attachEvent('onclick', domEventHandler('click', action), false);\r\n            detection_1._document.attachEvent('onkeypress', keypressHandler(action), false);\r\n        }\r\n    });\r\n};\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar source_1 = __webpack_require__(2);\r\nvar TraceKit = __webpack_require__(6);\r\nexports.default = function () {\r\n    return new source_1.default('exception', function (action) {\r\n        TraceKit.report.subscribe(function (errorMsg) {\r\n            action({\r\n                type: 'error',\r\n                category: 'error',\r\n                payload: errorMsg\r\n            });\r\n        });\r\n    });\r\n};\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// raven.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6faffaa71edddc62aa6e","import { hasJSON } from './detection'\n\n/**\n * Polyfill a method\n * @param obj object e.g. `document`\n * @param name method name present on object e.g. `addEventListener`\n * @param replacement replacement function\n * @param track {optional} record instrumentation to an array\n */\nexport function fill(obj, name, replacement, track?) {\n  var orig = obj[name]\n  obj[name] = replacement(orig)\n  if (track) {\n    track.push([obj, name, orig])\n  }\n}\n\nexport interface IElementSerialization {\n  tag: string\n  class?: string[]\n  id?: string\n  data?: {\n    [key: string]: string\n  }\n}\n\nconst dataAttrRegex = /^data-/\n\nexport function serializeDOMElement(dom: HTMLElement) {\n  const dataSet = [].slice.call(dom.attributes)\n    .filter(attr => dataAttrRegex.test(attr.name))\n    .map(attr => [\n      attr.name.substr(5).replace(/-(.)/g, ($0, $1) => $1.toUpperCase()),\n      attr.value\n    ])\n\n  const data = {}\n  for (const [ key, value ] of dataSet) {\n    data[key] = value\n  }\n\n  const serialization: IElementSerialization = {\n    tag: dom.tagName,\n    class: dom.className !== '' ? dom.className.split(' ').filter(Boolean): null,\n    id: dom.id || null,\n    data\n  }\n\n  return serialization\n}\n\nconst MAX_TRAVERSE_HEIGHT = 5\nconst MAX_OUTPUT_LEN = 80\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @param elem\n * @returns {string}\n */\nexport function htmlTreeAsString(elem) {\n  /* eslint no-extra-parens:0*/\n  const out = []\n  const separator = ' > '\n  const sepLength = separator.length\n  let height = 0\n  let len = 0\n  let nextStr\n\n  while (elem && height++ < MAX_TRAVERSE_HEIGHT) {\n\n    nextStr = htmlElementAsString(elem)\n    // bail out if\n    // - nextStr is the 'html' element\n    // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n    //   (ignore this limit if we are on the first iteration)\n    if (nextStr === 'html' || height > 1 && len + (out.length * sepLength) + nextStr.length >= MAX_OUTPUT_LEN) {\n      break\n    }\n\n    out.push(nextStr)\n\n    len += nextStr.length\n    elem = elem.parentNode\n  }\n\n  return out.reverse().join(separator)\n}\n\n/**\n* Returns a simple, query-selector representation of a DOM element\n* e.g. [HTMLElement] => input#foo.btn[name=baz]\n* @param HTMLElement\n* @returns {string}\n*/\nexport function htmlElementAsString(elem) {\n  const out = []\n  let className\n  let classes\n  let key\n  let attr\n  let i\n\n  if (!elem || !elem.tagName) {\n    return ''\n  }\n\n  out.push(elem.tagName.toLowerCase())\n  if (elem.id) {\n    out.push('#' + elem.id)\n  }\n\n  className = elem.className\n  if (className && typeof className === 'string') {\n    classes = className.split(/\\s+/)\n    for (i = 0; i < classes.length; i++) {\n      out.push('.' + classes[i])\n    }\n  }\n  var attrWhitelist = ['type', 'name', 'title', 'alt']\n  for (i = 0; i < attrWhitelist.length; i++) {\n    key = attrWhitelist[i]\n    attr = elem.getAttribute(key)\n    if (attr) {\n      out.push('[' + key + '=\"' + attr + '\"]')\n    }\n  }\n  return out.join('')\n}\n\nconst objectPrototype = Object.prototype\n\n/**\n * hasKey, a better form of hasOwnProperty\n * Example: hasKey(MainHostObject, property) === true/false\n *\n * @param {Object} host object to check property\n * @param {string} key to check\n */\nexport function hasKey(object, key) {\n  return objectPrototype.hasOwnProperty.call(object, key);\n}\n\nexport function merge(target, source) {\n  const obj: any = {}\n\n  for (const key in target) { obj[key] = target[key] }\n  for (const key in source) { obj[key] = source[key] }\n\n  return obj\n}\n\n// Simple type check utils\nexport function isString(raw) {\n  return typeof raw === 'string'\n}\n\nexport function isNull(raw) {\n  return raw === null\n}\n\nexport function isUndefined(raw) {\n  return raw === void 0\n}\n\nexport function isObject(raw) {\n  return typeof raw === 'object'\n}\n\nexport function isError(raw) {\n  return raw instanceof Error\n}\n\nexport function isNil(raw) {\n  return isNull(raw) || isUndefined(raw)\n}\n\nexport function isFunction(raw) {\n  return typeof raw === 'function' &&\n    raw.call && raw.apply\n}\n\nexport function isArray(raw) {\n  return raw instanceof Array && raw.push && raw.pop && raw.length\n}\n\nexport function clone(raw) {\n  if (hasJSON) {\n    return JSON.parse(JSON.stringify(raw))\n  } else {\n    return raw\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.ts","declare const global: any\n\nimport {\n  isUndefined, isObject, isError, isNil\n} from './utils'\n\nexport const _window = !isUndefined(window) ? window\n              : !isUndefined(global) ? global\n              : !isUndefined(self) ? self\n              : {}\nexport const _document = _window['document']\nexport const _navigator = _window['navigator']\n\nexport const hasJSON = !!(isObject(JSON) && !isNil(JSON.stringify))\nexport const hasDocument = !isUndefined(_document)\nexport const hasNavigator = !isUndefined(_navigator)\n\n\n\n// WEBPACK FOOTER //\n// ./src/detection.ts","import { merge } from './utils'\n\nexport type SourceMessageType = 'message' | 'error'\nexport interface ISourceMessage {\n  url?: string\n  type?: SourceMessageType\n  category: string\n  payload: any\n  timestamp?: number\n  user?: any\n  tags?: any\n  extra?: any\n}\nexport type ActionFunc<T> = (message: T) => any\nexport type ProcessorFunc<T> = (actionFunc: ActionFunc<T>) => any\n\nconst GEN_DEFAULT_SOURCE_MESSAGE = (): ISourceMessage => ({\n  type: 'message',\n  category: 'message',\n  payload: {},\n  timestamp: Date.now()\n})\n\nexport default class Source<T> {\n\n  name: string\n  processor: ProcessorFunc<T>\n  receivers: ActionFunc<T>[] = []\n\n  /**\n   * Class Source\n   * @param {string} name Name of the source to identify\n   * @param {function} processorFunc The processing function of the source\n   * \n   * @example\n   * new Source((action) => {\n   *   whenSomethingHappen((value) => {\n   *     action({\n   *       category: 'something',\n   *       payload: value\n   *     })\n   *   })\n   * })\n   */\n  constructor(name: string, processorFunc: ProcessorFunc<T>) {\n    this.name = name\n    this.processor = processorFunc\n\n    processorFunc(this.action.bind(this))\n  }\n\n  /**\n   * Fire the message to raven\n   * @param {ISourceMessage} message \n   */\n  action(message: ISourceMessage) {\n    const mergedMessage = merge(GEN_DEFAULT_SOURCE_MESSAGE(), message)\n\n    this.receivers.forEach((receiver) => receiver(mergedMessage))\n  }\n\n  /**\n   * bind the message event (only call by raven internally)\n   * @param callback \n   */\n  onAction(callback: ActionFunc<T>) {\n    this.receivers.push(callback)\n  }\n\n  /**\n   * Dispose the source (only call by raven internally)\n   */\n  dispose() {\n    this.receivers.forEach((receiver) => receiver = null)\n    this.receivers = []\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/source.ts","const stringify = JSON.stringify\n\nexport type ValidKeyType = string | symbol\nexport type ValidValueType = string | number | symbol | boolean | any[] | any\n\nexport class Storage {\n  data: { [key: string]: ValidValueType } = {}\n  \n  setItem(key: ValidKeyType, value: ValidValueType) {\n    this.data[key] = value\n  }\n\n  getItem(key: ValidKeyType) {\n    const value = this.data[key]\n\n    return value\n  }\n\n  removeItem(key: ValidKeyType) {\n    delete this.data[key]\n  }\n\n  clear() {\n    this.data = {}\n  }\n}\n\nlet realStorage = null\n\nexport class Store {\n\n  type = Store\n\n  _storage?: any = new Storage()\n  name: string\n  keys: ValidKeyType[] = []\n\n  constructor(name: string) {\n    this.name = name\n  }\n\n  static bindRealStorage(storage: any) {\n    realStorage = storage\n  }\n\n  get storage() {\n    if (realStorage) {\n      return realStorage\n    } else {\n      return this._storage\n    }\n  }\n\n  set(key: ValidKeyType, value: ValidValueType) {\n    this.storage.setItem(`${this.name}:${key}`, stringify(value))\n\n    if (this.keys.indexOf(key) === -1) {\n      this.keys.push(key)\n    }\n\n    return value\n  }\n\n  get(key: ValidKeyType) {\n    const value = this.storage.getItem(`${this.name}:${key}`)\n    if (value) {\n      return JSON.parse(value)\n    } else {\n      return null\n    }\n  }\n\n  has(key: ValidKeyType) {\n    return this.keys.indexOf(key) >= 0\n  }\n\n  remove(key: ValidKeyType) {\n    this.storage.removeItem(`${this.name}:${key}`)\n    \n    const index = this.keys.indexOf(key)\n    if (index >= 0) {\n      this.keys.splice(index, 1)\n    }\n  }\n\n  clear() {\n    this.storage.clear()\n    this.keys = []\n  }\n\n  merge(source: any) {\n    for (const key in source) {\n      if (source.hasOwnProperty(key)) {\n        const value = source[key]\n        \n        this.set(key, value)\n      }\n    }\n  }\n\n  toJS() {\n    const object: any = {}\n    \n    for (const key of this.keys) {\n      object[key] = this.get(key)\n    }\n\n    return object\n  }\n}\n\nexport class CollectionStore<T> extends Store {\n\n  type = CollectionStore\n\n  get length() {\n    return this.collect().length\n  }\n\n  collect(): T[] {\n    return this.get('collection') || []\n  }\n\n  push(item: T) {\n    const current = this.collect()\n\n    current.push(item)\n\n    this._update(current)\n    return current.length\n  }\n\n  pop() {\n    const current = this.collect()\n    const item = current.pop()\n\n    this._update(current)\n\n    return item\n  }\n\n  shift() {\n    const current = this.collect()\n    const item = current.shift()\n\n    this._update(current)\n\n    return item\n  }\n\n  unshift(item: T) {\n    const current = this.collect()\n\n    current.unshift(item)\n\n    this._update(current)\n    return current.length\n  }\n\n  _update(collection) {\n    this.set('collection', collection)\n    this.set('length', collection.length)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/store.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 4\n// module chunks = 0 1","import { Store } from './store'\nimport { IMessage } from './messages-store'\nimport { ISourceMessage } from './source'\n\nexport type TransferFunc = (data?: any) => Promise<any>\n\nexport default class Transfer {\n\n  name: string\n  transfer?: TransferFunc\n  configStore: Store\n\n  queue: TransferFunc[] = []\n  running = false\n\n  constructor(name: string, transferFunc: TransferFunc = duplex) {\n    this.name = name\n    this.configStore = new Store(`transfer:${name}`)\n    this.transfer = transferFunc\n  }\n\n  config(key: string, value: string)\n  config(object: any)\n\n  config(keyOrObject: any, value?: string) {\n    if (typeof keyOrObject === 'string') {\n      const key: string = keyOrObject\n\n      this.configStore.set(key, value)\n    } else {\n      for (const key in keyOrObject) {\n        if (keyOrObject.hasOwnProperty(key)) {\n          const value = keyOrObject[key]\n          \n          this.config(key, value)\n        }\n      }\n    }\n  }\n\n  send(message: IMessage) {\n    const { data, sent } = message\n    this.queue.push(() => new Promise((resolve, reject) => {\n\n      this.transfer.call(this, this.extendMessage(data))\n        .then(() => {\n          message.sent = true\n        })\n        .then(resolve)\n        .catch(reject)\n    }))\n\n    if (!this.running) {\n      this.run()\n    }\n  }\n\n  extendMessage(message: ISourceMessage) {\n    if (this.configStore.has('user')) {\n      message['user'] = this.configStore.get('user')\n    }\n\n    if (this.configStore.has('tags')) {\n      message['tags'] = this.configStore.get('tags')\n    }\n\n    if (this.configStore.has('extra')) {\n      message['extra'] = this.configStore.get('extra')\n    }\n\n    if (this.configStore.has('release')) {\n      message['release'] = this.configStore.get('release')\n    }\n\n    if (this.configStore.has('environment')) {\n      message['environment'] = this.configStore.get('environment')\n    }\n\n    return message\n  }\n\n  run() {\n    const current = this.queue.splice(0, 1)[0] // .shift()\n\n    if (current) {\n      this.running = true\n\n      current()\n        .then(() => this.run())\n    } else {\n      this.running = false\n    }\n  }\n\n}\n\nfunction duplex(value) { return value }\n\n\n\n// WEBPACK FOOTER //\n// ./src/transfer.ts","/**\n * https://github.com/csnover/TraceKit\n * @license MIT\n * @namespace TraceKit\n */\n(function(window, undefined) {\nif (!window) {\n    return;\n}\n\nvar TraceKit = {};\nvar _oldTraceKit = window.TraceKit;\n\n// global reference to slice\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n\n/**\n * A better form of hasOwnProperty<br/>\n * Example: `_has(MainHostObject, property) === true/false`\n *\n * @param {Object} object to check property\n * @param {string} key to check\n * @return {Boolean} true if the object has the key and it is not inherited\n */\nfunction _has(object, key) {\n    return Object.prototype.hasOwnProperty.call(object, key);\n}\n\n/**\n * Returns true if the parameter is undefined<br/>\n * Example: `_isUndefined(val) === true/false`\n *\n * @param {*} what Value to check\n * @return {Boolean} true if undefined and false otherwise\n */\nfunction _isUndefined(what) {\n    return typeof what === 'undefined';\n}\n\n/**\n * Export TraceKit out to another variable<br/>\n * Example: `var TK = TraceKit.noConflict()`\n * @return {Object} The TraceKit object\n * @memberof TraceKit\n */\nTraceKit.noConflict = function noConflict() {\n    window.TraceKit = _oldTraceKit;\n    return TraceKit;\n};\n\n/**\n * Wrap any function in a TraceKit reporter<br/>\n * Example: `func = TraceKit.wrap(func);`\n *\n * @param {Function} func Function to be wrapped\n * @return {Function} The wrapped func\n * @memberof TraceKit\n */\nTraceKit.wrap = function traceKitWrapper(func) {\n    function wrapped() {\n        try {\n            return func.apply(this, arguments);\n        } catch (e) {\n            TraceKit.report(e);\n            throw e;\n        }\n    }\n    return wrapped;\n};\n\n/**\n * Cross-browser processing of unhandled exceptions\n *\n * Syntax:\n * ```js\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n * ```\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *     on top frame; column number is not guaranteed\n *   - Opera: full stack trace with line and column numbers\n *   - Chrome: full stack trace with line and column numbers\n *   - Safari: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *   - IE: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a TraceKit.StackTrace object as described in the\n * TraceKit.computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\nTraceKit.report = (function reportModuleWrapper() {\n    var handlers = [],\n        lastException = null,\n        lastExceptionStack = null;\n\n    /**\n     * Add a crash handler.\n     * @param {Function} handler\n     * @memberof TraceKit.report\n     */\n    function subscribe(handler) {\n        installGlobalHandler();\n        handlers.push(handler);\n    }\n\n    /**\n     * Remove a crash handler.\n     * @param {Function} handler\n     * @memberof TraceKit.report\n     */\n    function unsubscribe(handler) {\n        for (var i = handlers.length - 1; i >= 0; --i) {\n            if (handlers[i] === handler) {\n                handlers.splice(i, 1);\n            }\n        }\n\n        if (handlers.length === 0) {\n            window.onerror = _oldOnerrorHandler;\n            _onErrorHandlerInstalled = false;\n        }\n    }\n\n    /**\n     * Dispatch stack information to all handlers.\n     * @param {TraceKit.StackTrace} stack\n     * @param {boolean} isWindowError Is this a top-level window error?\n     * @param {Error=} error The error that's being handled (if available, null otherwise)\n     * @memberof TraceKit.report\n     * @throws An exception if an error occurs while calling an handler.\n     */\n    function notifyHandlers(stack, isWindowError, error) {\n        var exception = null;\n        if (isWindowError && !TraceKit.collectWindowErrors) {\n          return;\n        }\n        for (var i in handlers) {\n            if (_has(handlers, i)) {\n                try {\n                    handlers[i](stack, isWindowError, error);\n                } catch (inner) {\n                    exception = inner;\n                }\n            }\n        }\n\n        if (exception) {\n            throw exception;\n        }\n    }\n\n    var _oldOnerrorHandler, _onErrorHandlerInstalled;\n\n    /**\n     * Ensures all global unhandled exceptions are recorded.\n     * Supported by Gecko and IE.\n     * @param {string} message Error message.\n     * @param {string} url URL of script that generated the exception.\n     * @param {(number|string)} lineNo The line number at which the error occurred.\n     * @param {(number|string)=} columnNo The column number at which the error occurred.\n     * @param {Error=} errorObj The actual Error object.\n     * @memberof TraceKit.report\n     */\n    function traceKitWindowOnError(message, url, lineNo, columnNo, errorObj) {\n        var stack = null;\n\n        if (lastExceptionStack) {\n            TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n    \t    processLastException();\n        } else if (errorObj) {\n            stack = TraceKit.computeStackTrace(errorObj);\n            notifyHandlers(stack, true, errorObj);\n        } else {\n            var location = {\n              'url': url,\n              'line': lineNo,\n              'column': columnNo\n            };\n\n            var name;\n            var msg = message; // must be new var or will modify original `arguments`\n            if ({}.toString.call(message) === '[object String]') {\n                var groups = message.match(ERROR_TYPES_RE);\n                if (groups) {\n                    name = groups[1];\n                    msg = groups[2];\n                }\n            }\n\n            location.func = TraceKit.computeStackTrace.guessFunctionName(location.url, location.line);\n            location.context = TraceKit.computeStackTrace.gatherContext(location.url, location.line);\n            stack = {\n                'name': name,\n                'message': msg,\n                'mode': 'onerror',\n                'stack': [location]\n            };\n\n            notifyHandlers(stack, true, null);\n        }\n\n        if (_oldOnerrorHandler) {\n            return _oldOnerrorHandler.apply(this, arguments);\n        }\n\n        return false;\n    }\n\n    /**\n     * Install a global onerror handler\n     * @memberof TraceKit.report\n     */\n    function installGlobalHandler() {\n        if (_onErrorHandlerInstalled === true) {\n            return;\n        }\n\n        _oldOnerrorHandler = window.onerror;\n        window.onerror = traceKitWindowOnError;\n        _onErrorHandlerInstalled = true;\n    }\n\n    /**\n     * Process the most recent exception\n     * @memberof TraceKit.report\n     */\n    function processLastException() {\n        var _lastExceptionStack = lastExceptionStack,\n            _lastException = lastException;\n        lastExceptionStack = null;\n        lastException = null;\n        notifyHandlers(_lastExceptionStack, false, _lastException);\n    }\n\n    /**\n     * Reports an unhandled Error to TraceKit.\n     * @param {Error} ex\n     * @memberof TraceKit.report\n     * @throws An exception if an incomplete stack trace is detected (old IE browsers).\n     */\n    function report(ex) {\n        if (lastExceptionStack) {\n            if (lastException === ex) {\n                return; // already caught by an inner catch block, ignore\n            } else {\n              processLastException();\n            }\n        }\n\n        var stack = TraceKit.computeStackTrace(ex);\n        lastExceptionStack = stack;\n        lastException = ex;\n\n        // If the stack trace is incomplete, wait for 2 seconds for\n        // slow slow IE to see if onerror occurs or not before reporting\n        // this exception; otherwise, we will end up with an incomplete\n        // stack trace\n        setTimeout(function () {\n            if (lastException === ex) {\n                processLastException();\n            }\n        }, (stack.incomplete ? 2000 : 0));\n\n        throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n    }\n\n    report.subscribe = subscribe;\n    report.unsubscribe = unsubscribe;\n    return report;\n}());\n\n/**\n * An object representing a single stack frame.\n * @typedef {Object} StackFrame\n * @property {string} url The JavaScript or HTML file URL.\n * @property {string} func The function name, or empty for anonymous functions (if guessing did not work).\n * @property {string[]?} args The arguments passed to the function, if known.\n * @property {number=} line The line number, if known.\n * @property {number=} column The column number, if known.\n * @property {string[]} context An array of source code lines; the middle element corresponds to the correct line#.\n * @memberof TraceKit\n */\n\n/**\n * An object representing a JavaScript stack trace.\n * @typedef {Object} StackTrace\n * @property {string} name The name of the thrown exception.\n * @property {string} message The exception error message.\n * @property {TraceKit.StackFrame[]} stack An array of stack frames.\n * @property {string} mode 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace.\n * @memberof TraceKit\n */\n\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   ```js\n *   s = TraceKit.computeStackTrace.ofCaller([depth])\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n *   ```\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n * Tracing example:\n *  ```js\n *     function trace(message) {\n *         var stackInfo = TraceKit.computeStackTrace.ofCaller();\n *         var data = message + \"\\n\";\n *         for(var i in stackInfo.stack) {\n *             var item = stackInfo.stack[i];\n *             data += (item.func || '[anonymous]') + \"() in \" + item.url + \":\" + (item.line || '0') + \"\\n\";\n *         }\n *         if (window.console)\n *             console.info(data);\n *         else\n *             alert(data);\n *     }\n * ```\n * @memberof TraceKit\n * @namespace\n */\nTraceKit.computeStackTrace = (function computeStackTraceWrapper() {\n    var debug = false,\n        sourceCache = {};\n\n    /**\n     * Attempts to retrieve source code via XMLHttpRequest, which is used\n     * to look up anonymous function names.\n     * @param {string} url URL of source code.\n     * @return {string} Source contents.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function loadSource(url) {\n        if (!TraceKit.remoteFetching) { //Only attempt request if remoteFetching is on.\n            return '';\n        }\n        try {\n            var getXHR = function() {\n                try {\n                    return new window.XMLHttpRequest();\n                } catch (e) {\n                    // explicitly bubble up the exception if not found\n                    return new window.ActiveXObject('Microsoft.XMLHTTP');\n                }\n            };\n\n            var request = getXHR();\n            request.open('GET', url, false);\n            request.send('');\n            return request.responseText;\n        } catch (e) {\n            return '';\n        }\n    }\n\n    /**\n     * Retrieves source code from the source code cache.\n     * @param {string} url URL of source code.\n     * @return {Array.<string>} Source contents.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function getSource(url) {\n        if (typeof url !== 'string') {\n            return [];\n        }\n\n        if (!_has(sourceCache, url)) {\n            // URL needs to be able to fetched within the acceptable domain.  Otherwise,\n            // cross-domain errors will be triggered.\n            /*\n                Regex matches:\n                0 - Full Url\n                1 - Protocol\n                2 - Domain\n                3 - Port (Useful for internal applications)\n                4 - Path\n            */\n            var source = '';\n            var domain = '';\n            try { domain = window.document.domain; } catch (e) { }\n            var match = /(.*)\\:\\/\\/([^:\\/]+)([:\\d]*)\\/{0,1}([\\s\\S]*)/.exec(url);\n            if (match && match[2] === domain) {\n                source = loadSource(url);\n            }\n            sourceCache[url] = source ? source.split('\\n') : [];\n        }\n\n        return sourceCache[url];\n    }\n\n    /**\n     * Tries to use an externally loaded copy of source code to determine\n     * the name of a function by looking at the name of the variable it was\n     * assigned to, if any.\n     * @param {string} url URL of source code.\n     * @param {(string|number)} lineNo Line number in source code.\n     * @return {string} The function name, if discoverable.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function guessFunctionName(url, lineNo) {\n        var reFunctionArgNames = /function ([^(]*)\\(([^)]*)\\)/,\n            reGuessFunction = /['\"]?([0-9A-Za-z$_]+)['\"]?\\s*[:=]\\s*(function|eval|new Function)/,\n            line = '',\n            maxLines = 10,\n            source = getSource(url),\n            m;\n\n        if (!source.length) {\n            return UNKNOWN_FUNCTION;\n        }\n\n        // Walk backwards from the first line in the function until we find the line which\n        // matches the pattern above, which is the function definition\n        for (var i = 0; i < maxLines; ++i) {\n            line = source[lineNo - i] + line;\n\n            if (!_isUndefined(line)) {\n                if ((m = reGuessFunction.exec(line))) {\n                    return m[1];\n                } else if ((m = reFunctionArgNames.exec(line))) {\n                    return m[1];\n                }\n            }\n        }\n\n        return UNKNOWN_FUNCTION;\n    }\n\n    /**\n     * Retrieves the surrounding lines from where an exception occurred.\n     * @param {string} url URL of source code.\n     * @param {(string|number)} line Line number in source code to center around for context.\n     * @return {?Array.<string>} Lines of source code.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function gatherContext(url, line) {\n        var source = getSource(url);\n\n        if (!source.length) {\n            return null;\n        }\n\n        var context = [],\n            // linesBefore & linesAfter are inclusive with the offending line.\n            // if linesOfContext is even, there will be one extra line\n            //   *before* the offending line.\n            linesBefore = Math.floor(TraceKit.linesOfContext / 2),\n            // Add one extra line if linesOfContext is odd\n            linesAfter = linesBefore + (TraceKit.linesOfContext % 2),\n            start = Math.max(0, line - linesBefore - 1),\n            end = Math.min(source.length, line + linesAfter - 1);\n\n        line -= 1; // convert to 0-based index\n\n        for (var i = start; i < end; ++i) {\n            if (!_isUndefined(source[i])) {\n                context.push(source[i]);\n            }\n        }\n\n        return context.length > 0 ? context : null;\n    }\n\n    /**\n     * Escapes special characters, except for whitespace, in a string to be\n     * used inside a regular expression as a string literal.\n     * @param {string} text The string.\n     * @return {string} The escaped string literal.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function escapeRegExp(text) {\n        return text.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#]/g, '\\\\$&');\n    }\n\n    /**\n     * Escapes special characters in a string to be used inside a regular\n     * expression as a string literal. Also ensures that HTML entities will\n     * be matched the same as their literal friends.\n     * @param {string} body The string.\n     * @return {string} The escaped string.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function escapeCodeAsRegExpForMatchingInsideHTML(body) {\n        return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('\"', '(?:\"|&quot;)').replace(/\\s+/g, '\\\\s+');\n    }\n\n    /**\n     * Determines where a code fragment occurs in the source code.\n     * @param {RegExp} re The function definition.\n     * @param {Array.<string>} urls A list of URLs to search.\n     * @return {?Object.<string, (string|number)>} An object containing\n     * the url, line, and column number of the defined function.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function findSourceInUrls(re, urls) {\n        var source, m;\n        for (var i = 0, j = urls.length; i < j; ++i) {\n            if ((source = getSource(urls[i])).length) {\n                source = source.join('\\n');\n                if ((m = re.exec(source))) {\n\n                    return {\n                        'url': urls[i],\n                        'line': source.substring(0, m.index).split('\\n').length,\n                        'column': m.index - source.lastIndexOf('\\n', m.index) - 1\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Determines at which column a code fragment occurs on a line of the\n     * source code.\n     * @param {string} fragment The code fragment.\n     * @param {string} url The URL to search.\n     * @param {(string|number)} line The line number to examine.\n     * @return {?number} The column number.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function findSourceInLine(fragment, url, line) {\n        var source = getSource(url),\n            re = new RegExp('\\\\b' + escapeRegExp(fragment) + '\\\\b'),\n            m;\n\n        line -= 1;\n\n        if (source && source.length > line && (m = re.exec(source[line]))) {\n            return m.index;\n        }\n\n        return null;\n    }\n\n    /**\n     * Determines where a function was defined within the source code.\n     * @param {(Function|string)} func A function reference or serialized\n     * function definition.\n     * @return {?Object.<string, (string|number)>} An object containing\n     * the url, line, and column number of the defined function.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function findSourceByFunctionBody(func) {\n        if (_isUndefined(window && window.document)) {\n            return;\n        }\n\n        var urls = [window.location.href],\n            scripts = window.document.getElementsByTagName('script'),\n            body,\n            code = '' + func,\n            codeRE = /^function(?:\\s+([\\w$]+))?\\s*\\(([\\w\\s,]*)\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/,\n            eventRE = /^function on([\\w$]+)\\s*\\(event\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/,\n            re,\n            parts,\n            result;\n\n        for (var i = 0; i < scripts.length; ++i) {\n            var script = scripts[i];\n            if (script.src) {\n                urls.push(script.src);\n            }\n        }\n\n        if (!(parts = codeRE.exec(code))) {\n            re = new RegExp(escapeRegExp(code).replace(/\\s+/g, '\\\\s+'));\n        }\n\n        // not sure if this is really necessary, but I dont have a test\n        // corpus large enough to confirm that and it was in the original.\n        else {\n            var name = parts[1] ? '\\\\s+' + parts[1] : '',\n                args = parts[2].split(',').join('\\\\s*,\\\\s*');\n\n            body = escapeRegExp(parts[3]).replace(/;$/, ';?'); // semicolon is inserted if the function ends with a comment.replace(/\\s+/g, '\\\\s+');\n            re = new RegExp('function' + name + '\\\\s*\\\\(\\\\s*' + args + '\\\\s*\\\\)\\\\s*{\\\\s*' + body + '\\\\s*}');\n        }\n\n        // look for a normal function definition\n        if ((result = findSourceInUrls(re, urls))) {\n            return result;\n        }\n\n        // look for an old-school event handler function\n        if ((parts = eventRE.exec(code))) {\n            var event = parts[1];\n            body = escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);\n\n            // look for a function defined in HTML as an onXXX handler\n            re = new RegExp('on' + event + '=[\\\\\\'\"]\\\\s*' + body + '\\\\s*[\\\\\\'\"]', 'i');\n\n            if ((result = findSourceInUrls(re, urls[0]))) {\n                return result;\n            }\n\n            // look for ???\n            re = new RegExp(body);\n\n            if ((result = findSourceInUrls(re, urls))) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    // Contents of Exception in various browsers.\n    //\n    // SAFARI:\n    // ex.message = Can't find variable: qq\n    // ex.line = 59\n    // ex.sourceId = 580238192\n    // ex.sourceURL = http://...\n    // ex.expressionBeginOffset = 96\n    // ex.expressionCaretOffset = 98\n    // ex.expressionEndOffset = 98\n    // ex.name = ReferenceError\n    //\n    // FIREFOX:\n    // ex.message = qq is not defined\n    // ex.fileName = http://...\n    // ex.lineNumber = 59\n    // ex.columnNumber = 69\n    // ex.stack = ...stack trace... (see the example below)\n    // ex.name = ReferenceError\n    //\n    // CHROME:\n    // ex.message = qq is not defined\n    // ex.name = ReferenceError\n    // ex.type = not_defined\n    // ex.arguments = ['aa']\n    // ex.stack = ...stack trace...\n    //\n    // INTERNET EXPLORER:\n    // ex.message = ...\n    // ex.name = ReferenceError\n    //\n    // OPERA:\n    // ex.message = ...message... (see the example below)\n    // ex.name = ReferenceError\n    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n    /**\n     * Computes stack trace information from the stack property.\n     * Chrome and Gecko use this property.\n     * @param {Error} ex\n     * @return {?TraceKit.StackTrace} Stack trace information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceFromStackProp(ex) {\n        if (!ex.stack) {\n            return null;\n        }\n\n        var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i,\n            gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i,\n            winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i,\n\n            // Used to additionally parse URL/line/column from eval frames\n            isEval,\n            geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i,\n            chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/,\n\n            lines = ex.stack.split('\\n'),\n            stack = [],\n            submatch,\n            parts,\n            element,\n            reference = /^(.*) is undefined$/.exec(ex.message);\n\n        for (var i = 0, j = lines.length; i < j; ++i) {\n            if ((parts = chrome.exec(lines[i]))) {\n                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n                isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n                if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n                    // throw out eval line/column and use top-most line/column number\n                    parts[2] = submatch[1]; // url\n                    parts[3] = submatch[2]; // line\n                    parts[4] = submatch[3]; // column\n                }\n                element = {\n                    'url': !isNative ? parts[2] : null,\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': isNative ? [parts[2]] : [],\n                    'line': parts[3] ? +parts[3] : null,\n                    'column': parts[4] ? +parts[4] : null\n                };\n            } else if ( parts = winjs.exec(lines[i]) ) {\n                element = {\n                    'url': parts[2],\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': [],\n                    'line': +parts[3],\n                    'column': parts[4] ? +parts[4] : null\n                };\n            } else if ((parts = gecko.exec(lines[i]))) {\n                isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n                if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n                    // throw out eval line/column and use top-most line number\n                    parts[3] = submatch[1];\n                    parts[4] = submatch[2];\n                    parts[5] = null; // no column when eval\n                } else if (i === 0 && !parts[5] && !_isUndefined(ex.columnNumber)) {\n                    // FireFox uses this awesome columnNumber property for its top frame\n                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n                    // so adding 1\n                    // NOTE: this hack doesn't work if top-most frame is eval\n                    stack[0].column = ex.columnNumber + 1;\n                }\n                element = {\n                    'url': parts[3],\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': parts[2] ? parts[2].split(',') : [],\n                    'line': parts[4] ? +parts[4] : null,\n                    'column': parts[5] ? +parts[5] : null\n                };\n            } else {\n                continue;\n            }\n\n            if (!element.func && element.line) {\n                element.func = guessFunctionName(element.url, element.line);\n            }\n\n            element.context = element.line ? gatherContext(element.url, element.line) : null;\n            stack.push(element);\n        }\n\n        if (!stack.length) {\n            return null;\n        }\n\n        if (stack[0] && stack[0].line && !stack[0].column && reference) {\n            stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);\n        }\n\n        return {\n            'mode': 'stack',\n            'name': ex.name,\n            'message': ex.message,\n            'stack': stack\n        };\n    }\n\n    /**\n     * Computes stack trace information from the stacktrace property.\n     * Opera 10+ uses this property.\n     * @param {Error} ex\n     * @return {?TraceKit.StackTrace} Stack trace information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceFromStacktraceProp(ex) {\n        // Access and store the stacktrace property before doing ANYTHING\n        // else to it because Opera is not very good at providing it\n        // reliably in other circumstances.\n        var stacktrace = ex.stacktrace;\n        if (!stacktrace) {\n            return;\n        }\n\n        var opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i,\n            opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i,\n            lines = stacktrace.split('\\n'),\n            stack = [],\n            parts;\n\n        for (var line = 0; line < lines.length; line += 2) {\n            var element = null;\n            if ((parts = opera10Regex.exec(lines[line]))) {\n                element = {\n                    'url': parts[2],\n                    'line': +parts[1],\n                    'column': null,\n                    'func': parts[3],\n                    'args':[]\n                };\n            } else if ((parts = opera11Regex.exec(lines[line]))) {\n                element = {\n                    'url': parts[6],\n                    'line': +parts[1],\n                    'column': +parts[2],\n                    'func': parts[3] || parts[4],\n                    'args': parts[5] ? parts[5].split(',') : []\n                };\n            }\n\n            if (element) {\n                if (!element.func && element.line) {\n                    element.func = guessFunctionName(element.url, element.line);\n                }\n                if (element.line) {\n                    try {\n                        element.context = gatherContext(element.url, element.line);\n                    } catch (exc) {}\n                }\n\n                if (!element.context) {\n                    element.context = [lines[line + 1]];\n                }\n\n                stack.push(element);\n            }\n        }\n\n        if (!stack.length) {\n            return null;\n        }\n\n        return {\n            'mode': 'stacktrace',\n            'name': ex.name,\n            'message': ex.message,\n            'stack': stack\n        };\n    }\n\n    /**\n     * NOT TESTED.\n     * Computes stack trace information from an error message that includes\n     * the stack trace.\n     * Opera 9 and earlier use this method if the option to show stack\n     * traces is turned on in opera:config.\n     * @param {Error} ex\n     * @return {?TraceKit.StackTrace} Stack information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceFromOperaMultiLineMessage(ex) {\n        // TODO: Clean this function up\n        // Opera includes a stack trace into the exception message. An example is:\n        //\n        // Statement on line 3: Undefined variable: undefinedFunc\n        // Backtrace:\n        //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\n        //         undefinedFunc(a);\n        //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\n        //           zzz(x, y, z);\n        //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\n        //           yyy(a, a, a);\n        //   Line 1 of function script\n        //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\n        //   ...\n\n        var lines = ex.message.split('\\n');\n        if (lines.length < 4) {\n            return null;\n        }\n\n        var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\n            lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\n            lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i,\n            stack = [],\n            scripts = (window && window.document && window.document.getElementsByTagName('script')),\n            inlineScriptBlocks = [],\n            parts;\n\n        for (var s in scripts) {\n            if (_has(scripts, s) && !scripts[s].src) {\n                inlineScriptBlocks.push(scripts[s]);\n            }\n        }\n\n        for (var line = 2; line < lines.length; line += 2) {\n            var item = null;\n            if ((parts = lineRE1.exec(lines[line]))) {\n                item = {\n                    'url': parts[2],\n                    'func': parts[3],\n                    'args': [],\n                    'line': +parts[1],\n                    'column': null\n                };\n            } else if ((parts = lineRE2.exec(lines[line]))) {\n                item = {\n                    'url': parts[3],\n                    'func': parts[4],\n                    'args': [],\n                    'line': +parts[1],\n                    'column': null // TODO: Check to see if inline#1 (+parts[2]) points to the script number or column number.\n                };\n                var relativeLine = (+parts[1]); // relative to the start of the <SCRIPT> block\n                var script = inlineScriptBlocks[parts[2] - 1];\n                if (script) {\n                    var source = getSource(item.url);\n                    if (source) {\n                        source = source.join('\\n');\n                        var pos = source.indexOf(script.innerText);\n                        if (pos >= 0) {\n                            item.line = relativeLine + source.substring(0, pos).split('\\n').length;\n                        }\n                    }\n                }\n            } else if ((parts = lineRE3.exec(lines[line]))) {\n                var url = window.location.href.replace(/#.*$/, '');\n                var re = new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[line + 1]));\n                var src = findSourceInUrls(re, [url]);\n                item = {\n                    'url': url,\n                    'func': '',\n                    'args': [],\n                    'line': src ? src.line : parts[1],\n                    'column': null\n                };\n            }\n\n            if (item) {\n                if (!item.func) {\n                    item.func = guessFunctionName(item.url, item.line);\n                }\n                var context = gatherContext(item.url, item.line);\n                var midline = (context ? context[Math.floor(context.length / 2)] : null);\n                if (context && midline.replace(/^\\s*/, '') === lines[line + 1].replace(/^\\s*/, '')) {\n                    item.context = context;\n                } else {\n                    // if (context) alert(\"Context mismatch. Correct midline:\\n\" + lines[i+1] + \"\\n\\nMidline:\\n\" + midline + \"\\n\\nContext:\\n\" + context.join(\"\\n\") + \"\\n\\nURL:\\n\" + item.url);\n                    item.context = [lines[line + 1]];\n                }\n                stack.push(item);\n            }\n        }\n        if (!stack.length) {\n            return null; // could not parse multiline exception message as Opera stack trace\n        }\n\n        return {\n            'mode': 'multiline',\n            'name': ex.name,\n            'message': lines[0],\n            'stack': stack\n        };\n    }\n\n    /**\n     * Adds information about the first frame to incomplete stack traces.\n     * Safari and IE require this to get complete data on the first frame.\n     * @param {TraceKit.StackTrace} stackInfo Stack trace information from\n     * one of the compute* methods.\n     * @param {string} url The URL of the script that caused an error.\n     * @param {(number|string)} lineNo The line number of the script that\n     * caused an error.\n     * @param {string=} message The error generated by the browser, which\n     * hopefully contains the name of the object that caused the error.\n     * @return {boolean} Whether or not the stack information was\n     * augmented.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n        var initial = {\n            'url': url,\n            'line': lineNo\n        };\n\n        if (initial.url && initial.line) {\n            stackInfo.incomplete = false;\n\n            if (!initial.func) {\n                initial.func = guessFunctionName(initial.url, initial.line);\n            }\n\n            if (!initial.context) {\n                initial.context = gatherContext(initial.url, initial.line);\n            }\n\n            var reference = / '([^']+)' /.exec(message);\n            if (reference) {\n                initial.column = findSourceInLine(reference[1], initial.url, initial.line);\n            }\n\n            if (stackInfo.stack.length > 0) {\n                if (stackInfo.stack[0].url === initial.url) {\n                    if (stackInfo.stack[0].line === initial.line) {\n                        return false; // already in stack trace\n                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n                        stackInfo.stack[0].line = initial.line;\n                        stackInfo.stack[0].context = initial.context;\n                        return false;\n                    }\n                }\n            }\n\n            stackInfo.stack.unshift(initial);\n            stackInfo.partial = true;\n            return true;\n        } else {\n            stackInfo.incomplete = true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Computes stack trace information by walking the arguments.caller\n     * chain at the time the exception occurred. This will cause earlier\n     * frames to be missed but is the only way to get any stack trace in\n     * Safari and IE. The top frame is restored by\n     * {@link augmentStackTraceWithInitialElement}.\n     * @param {Error} ex\n     * @return {TraceKit.StackTrace=} Stack trace information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceByWalkingCallerChain(ex, depth) {\n        var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n            stack = [],\n            funcs = {},\n            recursion = false,\n            parts,\n            item,\n            source;\n\n        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n            if (curr === computeStackTrace || curr === TraceKit.report) {\n                continue;\n            }\n\n            item = {\n                'url': null,\n                'func': UNKNOWN_FUNCTION,\n                'args': [],\n                'line': null,\n                'column': null\n            };\n\n            if (curr.name) {\n                item.func = curr.name;\n            } else if ((parts = functionName.exec(curr.toString()))) {\n                item.func = parts[1];\n            }\n\n            if (typeof item.func === 'undefined') {\n              try {\n                item.func = parts.input.substring(0, parts.input.indexOf('{'));\n              } catch (e) { }\n            }\n\n            if ((source = findSourceByFunctionBody(curr))) {\n                item.url = source.url;\n                item.line = source.line;\n\n                if (item.func === UNKNOWN_FUNCTION) {\n                    item.func = guessFunctionName(item.url, item.line);\n                }\n\n                var reference = / '([^']+)' /.exec(ex.message || ex.description);\n                if (reference) {\n                    item.column = findSourceInLine(reference[1], source.url, source.line);\n                }\n            }\n\n            if (funcs['' + curr]) {\n                recursion = true;\n            }else{\n                funcs['' + curr] = true;\n            }\n\n            stack.push(item);\n        }\n\n        if (depth) {\n            stack.splice(0, depth);\n        }\n\n        var result = {\n            'mode': 'callers',\n            'name': ex.name,\n            'message': ex.message,\n            'stack': stack\n        };\n        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n        return result;\n    }\n\n    /**\n     * Computes a stack trace for an exception.\n     * @param {Error} ex\n     * @param {(string|number)=} depth\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTrace(ex, depth) {\n        var stack = null;\n        depth = (depth == null ? 0 : +depth);\n\n        try {\n            // This must be tried first because Opera 10 *destroys*\n            // its stacktrace property if you try to access the stack\n            // property first!!\n            stack = computeStackTraceFromStacktraceProp(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceFromStackProp(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceFromOperaMultiLineMessage(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        return {\n            'name': ex.name,\n            'message': ex.message,\n            'mode': 'failed'\n        };\n    }\n\n    /**\n     * Logs a stacktrace starting from the previous call and working down.\n     * @param {(number|string)=} depth How many frames deep to trace.\n     * @return {TraceKit.StackTrace} Stack trace information.\n     * @memberof TraceKit.computeStackTrace\n     */\n    function computeStackTraceOfCaller(depth) {\n        depth = (depth == null ? 0 : +depth) + 1; // \"+ 1\" because \"ofCaller\" should drop one frame\n        try {\n            throw new Error();\n        } catch (ex) {\n            return computeStackTrace(ex, depth + 1);\n        }\n    }\n\n    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n    computeStackTrace.guessFunctionName = guessFunctionName;\n    computeStackTrace.gatherContext = gatherContext;\n    computeStackTrace.ofCaller = computeStackTraceOfCaller;\n    computeStackTrace.getSource = getSource;\n\n    return computeStackTrace;\n}());\n\n/**\n * Extends support for global error handling for asynchronous browser\n * functions. Adopted from Closure Library's errorhandler.js\n * @memberof TraceKit\n */\nTraceKit.extendToAsynchronousCallbacks = function () {\n    var _helper = function _helper(fnName) {\n        var originalFn = window[fnName];\n        window[fnName] = function traceKitAsyncExtension() {\n            // Make a copy of the arguments\n            var args = _slice.call(arguments);\n            var originalCallback = args[0];\n            if (typeof (originalCallback) === 'function') {\n                args[0] = TraceKit.wrap(originalCallback);\n            }\n            // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it\n            // also only supports 2 argument and doesn't care what \"this\" is, so we\n            // can just call the original function directly.\n            if (originalFn.apply) {\n                return originalFn.apply(this, args);\n            } else {\n                return originalFn(args[0], args[1]);\n            }\n        };\n    };\n\n    _helper('setTimeout');\n    _helper('setInterval');\n};\n\n//Default options:\nif (!TraceKit.remoteFetching) {\n    TraceKit.remoteFetching = true;\n}\nif (!TraceKit.collectWindowErrors) {\n    TraceKit.collectWindowErrors = true;\n}\nif (!TraceKit.linesOfContext || TraceKit.linesOfContext < 1) {\n    // 5 lines before, the offending line, 5 lines after\n    TraceKit.linesOfContext = 11;\n}\n\n// UMD export\nif (typeof define === 'function' && define.amd) {\n    define('TraceKit', [], TraceKit);\n} else if (typeof module !== 'undefined' && module.exports && window.module !== module) {\n    module.exports = TraceKit;\n} else {\n    window.TraceKit = TraceKit;\n}\n\n}(typeof window !== 'undefined' ? window : global));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tracekit/tracekit.js\n// module id = 6\n// module chunks = 0","export interface ILogger {\n  log?(message: string | any, ...args): void\n  info?(message: string | any, ...args): void\n  warn?(message: string | any, ...args): void\n  error?(message: string | Error, ...args): void\n}\n\nconst levels = [ 'log', 'info', 'warn', 'error' ]\nconst originalLevels: any = {}\nlevels.forEach((level) => originalLevels[level] = console[level])\n\nconst levelColors = {\n  qiniu: '#29a8e1',\n  normal: '#333',\n  log: '#86C166',   // NAE\n  info: '#006284',  // HANADA\n  warn: '#CA7A2C',  // KOHAKU\n  error: '#CB1B45'  // KURUNAI\n}\n\nconst logger: ILogger = {}\nlevels.forEach((level) => logger[level] = (message, ...args) => {\n  if (typeof message !== 'string' || args.length > 0) {\n    return originalLevels[level].apply(console, [ message ].concat(args))\n  }\n\n  return originalLevels[level].call(\n    console,\n    `%c[RAVEN-DEBUG] %c[${level.toUpperCase()}] %c${message}`,\n    `color: ${levelColors.qiniu}`,\n    `color: ${levelColors[level]}`,\n    `color: ${levelColors.normal}`\n  )\n})\n\nexport default logger\n\n// TODO: Logger could be a devtools\n\n\n// WEBPACK FOOTER //\n// ./src/logger.ts","import raven from './raven'\nmodule.exports = raven\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","declare const global: any\ndeclare const require: any\ndeclare let raven_option: IRavenOption\n\nimport * as TraceKit from 'tracekit'\n\n// Detection\nimport {\n  _window, _document, _navigator,\n  hasJSON, hasDocument, hasNavigator\n} from './detection'\n\n// Store\nimport { Store, CollectionStore } from './store'\nimport { MessagesStore } from './messages-store'\n\n// Transfer\nimport Transfer from './transfer'\n\n// Sources\nimport Source from './source'\nimport XHRSource from './sources/xhr'\nimport ConsoleSource from './sources/console'\nimport HistorySource from './sources/history'\nimport UIEventSource from './sources/ui-event'\nimport ExpectionSource from './sources/exception'\n\n// Logger\nimport logger, { ILogger } from './logger'\n\nimport {\n  hasKey, merge, clone,\n  isUndefined, isObject, isError, isNil, isFunction, isArray\n} from './utils'\n\nexport type URLPattern = RegExp | string\n\nexport interface IRavenOption {\n  release?: string\n  environment?: string\n  tags?: any\n  whitelistUrls?: URLPattern[]\n  ignoreUrls?: URLPattern[]\n  ignoreError?: string[]\n  autoInstall?: boolean\n  instrument?: boolean | {\n    tryCatch?: boolean\n  }\n  autoBreadcrumbs?: boolean | {\n    xhr?: boolean\n    console?: boolean\n    dom?: boolean\n    history?: boolean\n  }\n\n  transfer?: Transfer\n  transfers?: Transfer[]\n  sources?: Source<any>[]\n\n  debug?: boolean\n}\n\nconst DEFAULT_RAVEN_OPTION: IRavenOption = {\n  environment: 'production',\n  autoInstall: true,\n  instrument: {\n    tryCatch: true\n  },\n  autoBreadcrumbs: {\n    xhr: true,\n    console: true,\n    dom: true,\n    history: true\n  }\n}\n\nexport type ValueCallback<T> = (value?: T, callback?: ValueCallback<T>) => T\n\nexport class Raven {\n\n  VERSION: '3.13.1'\n\n  option: IRavenOption\n\n  callbacks: { [key: string]: ValueCallback<any> } = {}\n\n  configStore = new Store('config')\n  contextStore = new Store('context')\n  messages = new MessagesStore(this)\n\n  transfers: Transfer[] = []\n  sources: Source<any>[] = []\n\n  __wrappedBuiltins: any[] = []\n\n  get Transfer() {\n    return Transfer\n  }\n\n  get Source() {\n    return Source\n  }\n\n  get logger() {\n    return logger\n  }\n\n  /**\n   * Raven Constructor\n   * @param option Raven Option\n   */\n  constructor(option: IRavenOption = {}) {\n    this.option = merge(clone(DEFAULT_RAVEN_OPTION), option)\n\n    if (this.option.debug) {\n      this.debug = true\n    }\n\n    // Set Up\n    if (this.option.release) {\n      this.setRelease(this.option.release)\n    }\n\n    if (this.option.environment) {\n      this.setEnvironment(this.option.environment)\n    }\n\n    if (this.option.transfer) {\n      this.addTransfer(this.option.transfer)\n    }\n\n    if (this.option.transfers) {\n      for (const transfer of this.option.transfers) {\n        this.addTransfer(transfer)\n      }\n    }\n\n    if (this.option.sources) {\n      for (const source of this.option.sources) {\n        this.addSource(source)\n      }\n    }\n\n    if (this.option.autoInstall) {\n      this.install()\n    }\n  }\n\n  /**\n   * getter debug\n   * @return {boolean}\n   */\n  get debug(): boolean {\n    return this.configStore.get('debug') || false\n  }\n\n  /**\n   * setter debug\n   */\n  set debug(value) {\n    if (value === true) {\n      logger.info(`[CONFIG] set debug = ${value}`)\n    }\n\n    this.configStore.set('debug', value)\n  }\n\n  /**\n   * Install raven's instruments\n   * @return {Raven}\n   */\n  install() {\n    // Instrument TryCatch\n    if (this.option.instrument && this.option.instrument['tryCatch']) {\n      this.addSource(ExpectionSource())\n      if (_window) {\n        _window.onerror = (msg, source, line, col, err) => {\n          this.captureException(err)\n        }\n      }\n    }\n\n    // Instrumeny Breadcrumb\n    if (this.option.autoBreadcrumbs) {\n      this._setupBreadcrumb()\n    }\n\n    return this\n  }\n\n  /**\n   * Dispose raven\n   * @return {Raven}\n   */\n  uninstall() {\n    // Restore wrapped builtins\n    this._restoreBuiltIns()\n\n    // Dispose all sources\n    this.sources.forEach((source) => source.dispose())\n\n    return this\n  }\n\n  /**\n   * Add new source into raven\n   * \n   * @param {Source} source Data source\n   * @return {Raven}\n   * \n   * @example\n   * raven.addSource(source)\n   */\n  addSource(source: Source<any>) {\n    if (!source) return\n\n    source.onAction((message) => this.messages.add(message))\n\n    this.sources.push(source)\n\n    if (this.debug) {\n      this.logger.info(`[SOURCE] added source ${source.name}`)\n    }\n\n    return this\n  }\n\n  /**\n   * add a data transfer\n   * \n   * @param {Transfer} transfer Custom data transfer\n   * @return {Raven}\n   * \n   * @example\n   * raven.addTransfer(transfer)\n   */\n  addTransfer(transfer: Transfer) {\n    transfer.config(this.configStore.toJS())\n\n    this.transfers.push(transfer)\n    \n    if (this.debug) {\n      this.logger.info(`[TRANSFER] added transfer ${transfer.name}`)\n    }\n\n    return this\n  }\n\n  /**\n   * Set single config value of raven\n   * \n   * @param {string} key Key of the config\n   * @param {string} value Value\n   * @return {Raven}\n   * \n   * @example\n   * raven.config('foo', 'bar')\n   */\n  config(key: string, value: string)\n\n  /**\n   * Set batch of config values\n   * \n   * @param {Object} object Config\n   * @return {Raven}\n   * \n   * @example\n   * raven.config({\n   *   'foo': 1,\n   *   'bar': 2\n   * })\n   */\n  config(object: any)\n\n  config(keyOrObject: any, value?: string) {\n    if (typeof keyOrObject === 'string') {\n      const key: string = keyOrObject\n\n      this.configStore.set(key, value)\n\n      if (this.debug) {\n        this.logger.info(`[CONFIG] set ${key} = ${value}`)\n      }\n    } else {\n      for (const key in keyOrObject) {\n        if (keyOrObject.hasOwnProperty(key)) {\n          const value = keyOrObject[key]\n          this.config(key, value)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Manually capture an exception and send it over to Sentry\n   *\n   * @param {error} ex An exception to be logged\n   * @param {object} options A specific set of options for this error [optional]\n   * @return {Raven}\n   * \n   * @example\n   * try {\n   *   // stuff...\n   * } catch(ex) {\n   *   raven.captureException(ex)\n   * }\n   * \n   * @example\n   * stuff().catch((ex) => raven.captureException(ex))\n   */\n  captureException(ex: Error, options: any = {}) {\n    // If not an Error is passed through, recall as a message instead\n    if (!isError(ex)) {\n      return this.captureException(ex, merge({\n        trimHeadFrames: 1,\n        stacktrace: true // if we fall back to captureMessage, default to attempting a new trace\n      }, options))\n    }\n\n    // TraceKit.report will re-raise any exception passed to it,\n    // which means you have to wrap it in try/catch. Instead, we\n    // can wrap it here and only re-raise if TraceKit.report\n    // raises an exception different from the one we asked to\n    // report on.\n    try {\n      TraceKit.report(ex)\n    } catch(ex1) {\n      if (ex !== ex1) {\n        throw ex1\n      }\n    }\n\n    if (this.debug) {\n      this.logger.error(`[EXCEPTION] capture exception: ${ex.message}`)\n    }\n\n    return this\n  }\n\n  /**\n   * Set a user to be sent along with the payload.\n   * \n   * @param {object} user An object representing user data [optional]\n   * @return {Raven}\n   * \n   * @example\n   * raven.setUserContext({\n   *   uid: 123456,\n   *   email: 'foobar@example.com'\n   * })\n   */\n  setUserContext(user) {\n    this.contextStore.set('user', user)\n\n    if (this.transfers.length > 0) {\n      this.transfers.forEach((transfer) => transfer.config(this.contextStore.toJS()))\n    }\n\n    if (this.debug) {\n      this.logger.info(`[CONTEXT] set user context: ${user}`)\n    }\n\n    return this\n  }\n\n  /**\n   * Merge tags to be sent along with the payload.\n   *\n   * @param {object} tags An object representing tags\n   * @return {Raven}\n   * \n   * @example\n   * raven.setTagsContext('tags', [ 'beta' ])\n   */\n  setTagsContext(tags) {\n    this.contextStore.set('tags', tags)\n    \n    if (this.transfers.length > 0) {\n      this.transfers.forEach((transfer) => transfer.config(this.contextStore.toJS()))\n    }\n    \n    if (this.debug) {\n      this.logger.info(`[CONTEXT] set tags context: ${tags}`)\n    }\n\n    return this\n  }\n\n  /**\n   * Merge extra attributes to be sent along with the payload.\n   *\n   * @param {object} extra An object representing extra data [optional]\n   * @return {Raven}\n   */\n  setExtraContext(extra) {\n    this.contextStore.set('extra', extra)\n\n    if (this.transfers.length > 0) {\n      this.transfers.forEach((transfer) => transfer.config(this.contextStore.toJS()))\n    }\n    \n    if (this.debug) {\n      this.logger.info(`[CONTEXT] set extra context: ${extra}`)\n    }\n    \n    return this\n  }\n\n  /**\n   * Clear all of the context.\n   *\n   * @return {Raven}\n   * \n   * @example\n   * raven.clearContext()\n   */\n  clearContext() {\n    this.contextStore.clear()\n    \n    if (this.debug) {\n      this.logger.info(`[CONTEXT] clear context`)\n    }\n\n    return this\n  }\n\n  /**\n   * Get a copy of the current context. This cannot be mutated.\n   *\n   * @return {object} copy of context\n   */\n  getContext() {\n    return this.contextStore.toJS()\n  }\n\n  /**\n   * Set environment of application\n   *\n   * @param {string} environment Typically something like 'production'.\n   * @return {Raven}\n   * \n   * @example\n   * raven.setEnvironment('development')\n   * raven.setEnvironment('production')\n   */\n  setEnvironment(env: string) {\n    this.contextStore.set('environment', env)\n    \n    if (this.debug) {\n      this.logger.info(`[CONTEXT] set environment context: ${env}`)\n    }\n\n    return this\n  }\n\n  /**\n   * Set release version of application\n   *\n   * @param {string} release Typically something like a git SHA to identify version\n   * @return {Raven}\n   * \n   * @example\n   * raven.setRelease('public-v0.1.0')\n   */\n  setRelease(release: string) {\n    this.contextStore.set('release', release)\n    \n    if (this.debug) {\n      this.logger.info(`[CONTEXT] set release context: ${release}`)\n    }\n\n    return this\n  }\n\n  /**\n   * Get the callback of the special point\n   * \n   * @param {string} key Key of callback\n   * @return {ValueCallback}\n   * \n   * @example\n   * raven.getCallback('breadcrumb')\n   */\n  getCallback(key: string) {\n    if (isNil(this.callbacks[key])) {\n      return () => false\n    }\n\n    return this.callbacks[key]\n  }\n\n  /**\n   * Set callback of special point\n   * \n   * @param {string} key Key of the point\n   * @param {ValueCallback} callback Callback\n   * \n   * @example\n   * raven.setCallback('breadcrumb', (message) => {\n   *   console.log(message)\n   * })\n   */\n  setCallback(key: string, callback?: ValueCallback<any>) {\n    if (isUndefined(callback)) {\n      this.callbacks[key] = null\n      \n      if (this.debug) {\n        logger.info(`[CALLBACK] remove ${key} callback`)\n      }\n    } else if (isFunction(callback)) {\n      this.callbacks[key] = callback\n      \n      if (this.debug) {\n        logger.info(`[CALLBACK] set ${key} callback`)\n      }\n    }\n  }\n\n  /**\n   * Set the breadcrumb callback option\n   *\n   * @param {ValueCallback} callback The callback to run which some breadcrumb\n   *                            message create\n   * @return {Raven}\n   */\n  setBreadcrumbCallback(callback: ValueCallback<any>) {\n    const original = this.getCallback('breadcrumb')\n    this.setCallback('breadcrumb', composeCallback(original, callback))\n  }\n\n  /**\n   * Set the dataCallback option\n   *\n   * @param {ValueCallback} callback The callback to run which some exception\n   *                            message create\n   * @return {Raven}\n   */\n  setExceptionCallback(callback: ValueCallback<any>) {\n    const original = this.getCallback('exception')\n    this.setCallback('exception', composeCallback(original, callback))\n  }\n\n  /**\n   * Wrap code within a context and returns back a new function to be executed\n   *\n   * @param {object} options A specific set of options for this context [optional]\n   * @param {function} func The function to be wrapped in a new context\n   * @param {function} func A function to call before the try/catch wrapper [optional, private]\n   * @return {function} The newly wrapped functions with a context\n   */\n  wrap(options, func?, _before?) {\n    // 1 argument has been passed, and it's not a function\n    // so just return it\n    if (isUndefined(func) && !isFunction(options)) {\n      return options\n    }\n\n    // option is optional\n    if (isFunction(options)) {\n      func = options\n      options = undefined\n    }\n\n    // At this point, we've passed along 2 arguments, and the second one\n    // is not a function either, so we'll just return the second argument.\n    if (!isFunction(func)) {\n      return func\n    }\n\n    // We don't wanna wrap it twice!\n    try {\n      if (func.__raven__) {\n        return func\n      }\n\n      // If this has already been wrapped in the past, return that\n      if (func.__raven_wrapper__)  {\n        return func.__raven_wrapper__\n      }\n    } catch (e) {\n      // Just accessing custom props in some Selenium environments\n      // can cause a \"Permission denied\" exception (see raven-js#495).\n      // Bail on wrapping and return the function as-is (defers to window.onerror).\n      return func\n    }\n\n    const self = this\n\n    function wrapped() {\n      var args = [], i = arguments.length,\n          deep = !options || options && options.deep !== false\n\n      if (_before && isFunction(_before)) {\n          _before.apply(this, arguments)\n      }\n\n      // Recursively wrap all of a function's arguments that are\n      // functions themselves.\n      while(i--) args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i]\n\n      try {\n        // Attempt to invoke user-land function\n        // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n        //       means Raven caught an error invoking your application code. This is\n        //       expected behavior and NOT indicative of a bug with Raven.js.\n        return func.apply(this, args)\n      } catch(e) {\n        self._ignoreNextOnError()\n        self.captureException(e, options)\n        throw e\n      }\n    }\n\n    for (const prop in func) {\n      if (hasKey(func, prop)) {\n        wrapped[prop] = func[prop]\n      }\n    }\n    wrapped.prototype = func.prototype\n\n    func.__raven_wrapper__ = wrapped\n    wrapped['__raven__'] = true\n    wrapped['__inner__'] = func\n\n    if (this.debug) {\n      const funcName = func.name || 'anynomous'\n      logger.info(`wrap function ${funcName}`)\n    }\n\n    return wrapped\n  }\n\n  /**\n   * Wrap code within a context so Raven can capture errors\n   * reliably across domains that is executed immediately.\n   *\n   * @param {function} func The callback to be immediately executed within the context\n   * @param {array} args An array of arguments to be called with the callback [optional]\n   * @param {object} options A specific set of options for this context [optional]\n   */\n  context(func, args: any[])\n  context(func, options: any)\n  context(func, args: any[], options: any)\n  context(func, argsOrOptions: any, options?: any) {\n    let args = null\n    let opts = undefined\n\n    switch (true) {\n      case isArray(argsOrOptions) && isUndefined(options):  // overload +1\n        args = argsOrOptions\n        break\n\n      case !isArray(argsOrOptions) && isUndefined(options):  // overload +2\n        args = []\n        opts = argsOrOptions\n        break\n\n      case isArray(argsOrOptions) && !isUndefined(options):  // overload +3\n        args = argsOrOptions\n        opts = options\n        break\n    }\n\n    return this.wrap(options, func).apply(this, args)\n  }\n\n  _ignoreOnError = 0\n\n  _ignoreNextOnError() {\n    this._ignoreOnError += 1\n    setTimeout(() => {\n      this._ignoreOnError -= 1\n    })\n  }\n\n  _setupBreadcrumb() {\n    if (this.option.autoBreadcrumbs['xhr'] || this.option.autoBreadcrumbs === true) {\n      this.addSource(XHRSource(this))\n    }\n\n    if (this.option.autoBreadcrumbs['history'] || this.option.autoBreadcrumbs === true) {\n      this.addSource(HistorySource(this))\n    }\n\n    if (this.option.autoBreadcrumbs['dom'] || this.option.autoBreadcrumbs === true) {\n      this.addSource(UIEventSource())\n    }\n\n    if (this.option.autoBreadcrumbs['console'] || this.option.autoBreadcrumbs === true) {\n      this.addSource(ConsoleSource())\n    }\n  }\n\n  _restoreBuiltIns() {\n    for (const [ obj, name, orig ] of this.__wrappedBuiltins) {\n      obj[name] = orig\n    }\n  }\n}\n\nconst raven = new Raven(_window.raven_option || {})\n\nexport default raven\n\nfunction composeCallback(original: ValueCallback<any>, callback: ValueCallback<any>): ValueCallback<any> {\n  return isFunction(callback)\n    ? (data) => callback(data, original)\n    : callback\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/raven.ts","import { CollectionStore } from './store'\nimport { ISourceMessage } from './source'\nimport { Raven } from './raven'\nimport { _window } from './detection'\n\nimport logger from './logger'\n\nexport interface IMessage {\n  id: number,\n  data: ISourceMessage\n  sent: boolean\n}\n\nconst breadcrumbCategories = [ 'console', 'history', 'ui.events', 'network' ]\nconst isBreadcrumb = (category: string) => {\n  return breadcrumbCategories.indexOf(category) >= 0\n}\n\nexport class MessagesStore {\n\n  counter = 0\n\n  parent: Raven\n  store = new CollectionStore<IMessage>('messages')\n\n  constructor(parent: Raven) {\n    this.parent = parent\n  }\n\n  add(data: ISourceMessage) {\n\n    if (_window && _window.location && _window.location.href) {\n      data.url = _window.location.href\n    }\n\n    const message: IMessage = {\n      id: ++this.counter,\n      data,\n      sent: false\n    }\n\n    this.store.push(message)\n\n    this.parent.transfers.forEach((transfer) => transfer.send(message))\n\n    if (isBreadcrumb(data.category)) {\n      this.parent.getCallback('breadcrumb')(data)\n    }\n\n    if (data.category === 'error') {\n      this.parent.getCallback('exception')(data)\n    }\n\n    if (this.parent.debug) {\n      logger.log(`[MESSAGES] New message added [${data.category}], messages count: ${this.store.length}`)\n      logger.log(`[MESSAGES]`, data)\n    }\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/messages-store.ts","import { Raven } from '../raven'\n\nimport Source, { ISourceMessage } from '../source'\nimport { isString, isFunction, fill } from '../utils'\nimport { _window } from '../detection' \n\nexport interface IXHRMessage extends ISourceMessage {\n  payload: {\n    action?: string\n    method: string\n    url: string\n    status_code?: string\n    duration?: number // 0 for timeout\n  }\n}\n\nfunction genXHRMessage(action: string, method: string, url: string, status_code: string = null) {\n  return {\n    action, method, url, status_code, duration: 0\n  }\n}\n\nexport default (raven: Raven) => {\n\n  function wrapProp(prop, xhr) {\n    if (prop in xhr && isFunction(xhr[prop])) {\n      fill(xhr, prop, (orig) => raven.wrap(orig)) // intentionally don't track filled methods on XHR instances\n    }\n  }\n\n  if (!_window) return null\n\n  return new Source<IXHRMessage>('breadcrumb.XHR', (action) => {\n    // XMLHttpRequest\n    if ('XMLHttpRequest' in _window) {\n      const xhrproto = XMLHttpRequest.prototype\n\n      fill(xhrproto, 'open', (originFunc) => {\n        return function(method, url) { // preserve arity\n          this.__raven_xhr = genXHRMessage('open', method, url)\n\n          return originFunc.apply(this, arguments)\n        }\n      }, raven.__wrappedBuiltins)\n\n      fill(xhrproto, 'send', (originFunc) => {\n        return function(data) { // preserve arity\n          const xhr = this\n\n          const startAt = Date.now()\n\n          const timeChecker = setTimeout(() => action({\n            category: 'network',\n            payload: xhr.__raven_xhr\n          }), 30 * 1000 /* 30 sec */)\n\n          function onreadystatechangeHandler() {\n            if (xhr.__raven_xhr && (xhr.readyState === 1 || xhr.readyState === 4)) {\n              if (timeChecker) {\n                clearTimeout(timeChecker)\n              }\n\n              try {\n                // touching statusCode in some platforms throws\n                // an exception\n                xhr.__raven_xhr.status_code = xhr.status\n                xhr.__raven_xhr.duration = Date.now() - startAt\n              } catch (e) { /* do nothing */ }\n\n              action({\n                category: 'netword',\n                payload: xhr.__raven_xhr\n              })\n            }\n          }\n\n          const props = [ 'onload', 'onerror', 'onprogress' ]\n          for (const prop of props) {\n            wrapProp(prop, xhr)\n          }\n\n          if ('onreadystatechange' in xhr && isFunction(xhr.onreadystatechange)) {\n            fill(xhr, 'onreadystatechange', (orig) => raven.wrap(orig, undefined, onreadystatechangeHandler))\n          } else {\n            xhr.onreadystatechange = onreadystatechangeHandler\n          }\n\n          return originFunc.apply(this, arguments)\n        }\n      }, raven.__wrappedBuiltins)\n    }\n\n    // Fetch API\n    if ('fetch' in _window) {\n      _window['_origin_fetch'] = _window.fetch\n      fill(_window, 'fetch', (origFetch) => {\n        return (...args) => {\n          const fetchInput = args[0]\n          let method = 'GET'\n          let url = null\n\n          if (typeof fetchInput === 'string') {\n            url = fetchInput\n          } else {\n            url = fetchInput.url\n            if (fetchInput.method) {\n              method = fetchInput.method\n            }\n          }\n\n          if (args[1] && args[1].method) {\n            method = args[1].method\n          }\n\n          const fetchData = {\n            method, url, status_code: null, duration: 0\n          }\n\n          const startAt = Date.now()\n\n          const timeChecker = setTimeout(() => action({\n            category: 'network',\n            payload: fetchData\n          }), 30 * 1000 /* 30 sec */)\n\n          return origFetch.apply(_window, args).then((resp) => {\n            if (timeChecker) {\n              clearTimeout(timeChecker)\n            }\n\n            fetchData.status_code = resp.status\n            fetchData.duration = Date.now() - startAt\n\n            action({\n              category: 'network',\n              payload: fetchData\n            })\n\n            return resp\n          })\n        }\n      }, raven.__wrappedBuiltins)\n    }\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/sources/xhr.ts","import Source from '../source'\n\nexport function wrapMethod(console, level, callback) {\n  const originalConsoleLevel = console[level]\n  const originalConsole = console\n\n  if (!(level in console)) {\n    return\n  }\n\n  console[`_origin_${level}`] = originalConsoleLevel\n  console[level] = function(...args) {\n    const msg = args.join(' ')\n    const data = {\n      level,\n      logger: 'console',\n      extra: {\n        'arguments': args\n      }\n    }\n\n    if (originalConsoleLevel) {\n      Function.prototype.apply.call(\n        originalConsoleLevel,\n        originalConsole,\n        args\n      )\n    }\n\n    callback(msg, data)\n  }\n}\n\nconst levels = [ 'debug', 'info', 'warn', 'error', 'log' ]\n\nexport default () => {\n  return new Source('breadcrumb.console', (action) => {\n    const consoleMethodCallback = (msg, data) => {\n      action({\n        category: 'console',\n        payload: {\n          level: data.level,\n          message: msg\n        }\n      })\n    }\n\n    for (const level of levels) {\n      wrapMethod(console, level, consoleMethodCallback)\n    }\n  })\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/sources/console.ts","import { Raven } from '../raven'\n\nimport Source, { ISourceMessage } from '../source'\nimport { fill } from '../utils'\nimport { _window, _navigator, _document } from '../detection'\n\nexport interface IHistoryMessage extends ISourceMessage {\n  payload: {\n    from?: string\n    to: string\n    pageSize?: {\n      width: number\n      height: number\n    }\n    screenSize?: {\n      width: number\n      height: number\n    }\n    pageView?: boolean\n    userAgent?: string\n  }\n}\n\nexport default (raven: Raven) => {\n  if (!_window) return\n\n  const _location = _window.location\n  let _lastHref = _location && _location.href\n\n  // record navigation (URL) changes\n  // NOTE: in Chrome App environment, touching history.pushState, *even inside\n  //       a try/catch block*, will cause Chrome to output an error to console.error\n  // borrowed from: https://github.com/angular/angular.js/pull/13945/files\n  const chrome = _window.chrome\n  const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime\n  const hasPushState = !isChromePackagedApp && _window.history && history.pushState\n\n  if (!hasPushState) return\n\n  return new Source<IHistoryMessage>('breadcrumb.history', (action) => {\n    if (_window && _navigator && _document) {\n      // Push a navigation message when page load\n      const message: IHistoryMessage = {\n        category: 'navigation',\n        payload: {\n          to: _lastHref,\n          pageView: true,\n          pageSize: {\n            width: _document.body.offsetWidth,\n            height: _document.body.offsetHeight\n          },\n          screenSize: {\n            width: _window.screen.width,\n            height: _window.screen.height\n          },\n          userAgent: _navigator.userAgent\n        }\n      }\n\n      setTimeout(() => action(message), 1)\n    }\n\n    // TODO: remove onpopstate handler on uninstall()\n    var oldOnPopState = _window.onpopstate;\n    _window.onpopstate = function () {\n      const currentHref = _location.href\n\n      const message: IHistoryMessage = {\n        category: 'navigation',\n        payload: {\n          to: currentHref,\n          from: _lastHref\n        }\n      }\n\n      action(message)\n\n      _lastHref = currentHref\n\n      if (oldOnPopState) {\n        return oldOnPopState.apply(history, arguments)\n      }\n    }\n\n    fill(history, 'pushState', (origPushState) => {\n      // note history.pushState.length is 0; intentionally not declaring\n      // params to preserve 0 arity\n      return (...args) => {\n        const url = args.length > 2 ? args[2] : undefined\n\n        // url argument is optional\n        if (url) {\n          // coerce to string (this is what pushState does)\n          const message: IHistoryMessage = {\n            category: 'navigation',\n            payload: {\n              to: url,\n              from: _lastHref\n            }\n          }\n\n          action(message)\n\n          _lastHref = url\n        }\n\n        return origPushState.apply(history, args)\n      }\n    }, raven.__wrappedBuiltins)\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/sources/history.ts","import { Raven } from '../raven'\n\nimport Source, { ISourceMessage, ActionFunc } from '../source'\nimport { fill, htmlTreeAsString } from '../utils'\nimport { _document, hasDocument } from '../detection'\n\nlet _keypressTimeout = null\nlet _lastCapturedEvent = null\n\nfunction domEventHandler(evtName: string, action: ActionFunc<ISourceMessage>) {\n  return (evt) => {\n\n    // reset keypress timeout; e.g. triggering a 'click' after\n    // a 'keypress' will reset the keypress debounce so that a new\n    // set of keypresses can be recorded\n    _keypressTimeout = null\n\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors). Ignore if we've\n    // already captured the event.\n    if (_lastCapturedEvent === evt) return\n    \n    _lastCapturedEvent = evt\n\n    // try/catch both:\n    // - accessing evt.target (see getsentry/raven-js#838, #768)\n    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n    //   can throw an exception in some circumstances.\n    let target = null\n    try {\n      target = htmlTreeAsString(evt.target)\n    } catch(ex) {\n      target = '<unknown>'\n    }\n\n    const payload: any = {\n      event: evtName,\n      path: target\n    }\n\n    if (evtName === 'click' || evtName === 'touchstart') {\n      payload.pos = {\n        x: evt.pageX,\n        y: evt.pageY\n      }\n      payload.pageSize = {\n        width: _document.body.offsetWidth,\n        height: _document.body.offsetHeight\n      }\n    }\n\n    if (evtName === 'input') {\n      payload.value = evt.target.value\n    }\n\n    action({\n      category: 'ui.events',\n      payload\n    })\n  }\n}\n\nconst debounceDuration = 1000 // milliseconds\n\nfunction keypressHandler(action: ActionFunc<ISourceMessage>) {\n  return (evt) => {\n    let target\n    try {\n      target = evt.target\n    } catch(e) {\n      // just accessing event properties can throw an exception in some rare circumstances\n      // see: https://github.com/getsentry/raven-js/issues/838\n      return\n    }\n\n    const tagName = target && target.tagName\n\n    // only consider keypress events on actual input elements\n    // this will disregard keypresses targeting body (e.g. tabbing\n    // through elements, hotkeys, etc)\n    if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)\n      return\n\n    // record first keypress in a series, but ignore subsequent\n    // keypresses until debounce clears\n    const timeout = _keypressTimeout\n    if (!timeout) {\n      domEventHandler('input', action)(evt)\n    }\n    \n    clearTimeout(timeout)\n    _keypressTimeout = setTimeout(() => {\n      _keypressTimeout = null\n    }, debounceDuration)\n  }\n}\n\nexport default () => {\n  if (!_document || !hasDocument) return\n\n  return new Source('breadcrumb.DOMEvents', (action) => {\n    if (_document.addEventListener) {\n      _document.addEventListener('click', domEventHandler('click', action), false)\n      _document.addEventListener('keypress', keypressHandler(action), false)\n    } else {\n      // IE8 Compatibility\n      _document.attachEvent('onclick', domEventHandler('click', action), false)\n      _document.attachEvent('onkeypress', keypressHandler(action), false)\n    }\n  })\n}\n\n\n// WEBPACK FOOTER //\n// ./src/sources/ui-event.ts","import Source from '../source'\nimport * as TraceKit from 'tracekit'\n\nexport default () => {\n  return new Source('exception', (action) => {\n    TraceKit.report.subscribe((errorMsg) => {\n      action({\n        type: 'error',\n        category: 'error',\n        payload: errorMsg\n      })\n    })\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/sources/exception.ts"],"sourceRoot":""}